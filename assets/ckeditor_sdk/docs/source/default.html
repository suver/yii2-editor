<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

( function() {
	var fragmentPrototype = CKEDITOR.htmlParser.fragment.prototype,
		elementPrototype = CKEDITOR.htmlParser.element.prototype;

	fragmentPrototype.onlyChild = elementPrototype.onlyChild = function() {
		var children = this.children,
			count = children.length,
			firstChild = ( count == 1 ) &amp;&amp; children[ 0 ];
		return firstChild || null;
	};

	elementPrototype.removeAnyChildWithName = function( tagName ) {
		var children = this.children,
			childs = [],
			child;

		for ( var i = 0; i &lt; children.length; i++ ) {
			child = children[ i ];
			if ( !child.name )
				continue;

			if ( child.name == tagName ) {
				childs.push( child );
				children.splice( i--, 1 );
			}
			childs = childs.concat( child.removeAnyChildWithName( tagName ) );
		}
		return childs;
	};

	elementPrototype.getAncestor = function( tagNameRegex ) {
		var parent = this.parent;
		while ( parent &amp;&amp; !( parent.name &amp;&amp; parent.name.match( tagNameRegex ) ) )
			parent = parent.parent;
		return parent;
	};

	fragmentPrototype.firstChild = elementPrototype.firstChild = function( evaluator ) {
		var child;

		for ( var i = 0; i &lt; this.children.length; i++ ) {
			child = this.children[ i ];
			if ( evaluator( child ) )
				return child;
			else if ( child.name ) {
				child = child.firstChild( evaluator );
				if ( child )
					return child;
			}
		}

		return null;
	};

	// Adding a (set) of styles to the element&#39;s &#39;style&#39; attributes.
	elementPrototype.addStyle = function( name, value, isPrepend ) {
		var styleText,
			addingStyleText = &#39;&#39;;
		// name/value pair.
		if ( typeof value == &#39;string&#39; )
			addingStyleText += name + &#39;:&#39; + value + &#39;;&#39;;
		else {
			// style literal.
			if ( typeof name == &#39;object&#39; ) {
				for ( var style in name ) {
					if ( name.hasOwnProperty( style ) )
						addingStyleText += style + &#39;:&#39; + name[ style ] + &#39;;&#39;;
				}
			}
			// raw style text form.
			else {
				addingStyleText += name;
			}

			isPrepend = value;
		}

		if ( !this.attributes )
			this.attributes = {};

		styleText = this.attributes.style || &#39;&#39;;

		styleText = ( isPrepend ? [ addingStyleText, styleText ] : [ styleText, addingStyleText ] ).join( &#39;;&#39; );

		this.attributes.style = styleText.replace( /^;+|;(?=;)/g, &#39;&#39; );
	};

	// Retrieve a style property value of the element.
	elementPrototype.getStyle = function( name ) {
		var styles = this.attributes.style;
		if ( styles ) {
			styles = CKEDITOR.tools.parseCssText( styles, 1 );
			return styles[ name ];
		}
	};

<span id='CKEDITOR-dtd-method-parentOf'>	/**
</span>	 * Return the DTD-valid parent tag names of the specified one.
	 *
	 * @member CKEDITOR.dtd
	 * @param {String} tagName
	 * @returns {Object}
	 */
	CKEDITOR.dtd.parentOf = function( tagName ) {
		var result = {};
		for ( var tag in this ) {
			if ( tag.indexOf( &#39;$&#39; ) == -1 &amp;&amp; this[ tag ][ tagName ] )
				result[ tag ] = 1;
		}
		return result;
	};

	// 1. move consistent list item styles up to list root.
	// 2. clear out unnecessary list item numbering.
	function postProcessList( list ) {
		var children = list.children,
			child, attrs,
			count = list.children.length,
			match, mergeStyle,
			styleTypeRegexp = /list-style-type:(.*?)(?:;|$)/,
			stylesFilter = CKEDITOR.plugins.pastefromword.filters.stylesFilter;

		attrs = list.attributes;
		if ( styleTypeRegexp.exec( attrs.style ) )
			return;

		for ( var i = 0; i &lt; count; i++ ) {
			child = children[ i ];

			if ( child.attributes.value &amp;&amp; Number( child.attributes.value ) == i + 1 )
				delete child.attributes.value;

			match = styleTypeRegexp.exec( child.attributes.style );

			if ( match ) {
				if ( match[ 1 ] == mergeStyle || !mergeStyle )
					mergeStyle = match[ 1 ];
				else {
					mergeStyle = null;
					break;
				}
			}
		}

		if ( mergeStyle ) {
			for ( i = 0; i &lt; count; i++ ) {
				attrs = children[ i ].attributes;
				attrs.style &amp;&amp; ( attrs.style = stylesFilter( [ [ &#39;list-style-type&#39; ] ] )( attrs.style ) || &#39;&#39; );
			}

			list.addStyle( &#39;list-style-type&#39;, mergeStyle );
		}
	}

	var emptyMarginRegex = /^(?:\b0[^\s]*\s*){1,4}$/; // e.g. 0px 0pt 0px
	var romanLiternalPattern = &#39;^m{0,4}(cm|cd|d?c{0,3})(xc|xl|l?x{0,3})(ix|iv|v?i{0,3})$&#39;,
		lowerRomanLiteralRegex = new RegExp( romanLiternalPattern ),
		upperRomanLiteralRegex = new RegExp( romanLiternalPattern.toUpperCase() );

	var orderedPatterns = { &#39;decimal&#39;: /\d+/, &#39;lower-roman&#39;: lowerRomanLiteralRegex, &#39;upper-roman&#39;: upperRomanLiteralRegex, &#39;lower-alpha&#39;: /^[a-z]+$/, &#39;upper-alpha&#39;: /^[A-Z]+$/ },
		unorderedPatterns = { &#39;disc&#39;: /[l\u00B7\u2002]/, &#39;circle&#39;: /[\u006F\u00D8]/, &#39;square&#39;: /[\u006E\u25C6]/ },
		listMarkerPatterns = { &#39;ol&#39;: orderedPatterns, &#39;ul&#39;: unorderedPatterns },
		romans = [ [ 1000, &#39;M&#39; ], [ 900, &#39;CM&#39; ], [ 500, &#39;D&#39; ], [ 400, &#39;CD&#39; ], [ 100, &#39;C&#39; ], [ 90, &#39;XC&#39; ], [ 50, &#39;L&#39; ], [ 40, &#39;XL&#39; ], [ 10, &#39;X&#39; ], [ 9, &#39;IX&#39; ], [ 5, &#39;V&#39; ], [ 4, &#39;IV&#39; ], [ 1, &#39;I&#39; ] ],
		alpahbets = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;

	// Convert roman numbering back to decimal.
	function fromRoman( str ) {
		str = str.toUpperCase();
		var l = romans.length,
			retVal = 0;
		for ( var i = 0; i &lt; l; ++i ) {
			for ( var j = romans[ i ], k = j[ 1 ].length; str.substr( 0, k ) == j[ 1 ]; str = str.substr( k ) )
				retVal += j[ 0 ];
		}
		return retVal;
	}

	// Convert alphabet numbering back to decimal.
	function fromAlphabet( str ) {
		str = str.toUpperCase();
		var l = alpahbets.length,
			retVal = 1;
		for ( var x = 1; str.length &gt; 0; x *= l ) {
			retVal += alpahbets.indexOf( str.charAt( str.length - 1 ) ) * x;
			str = str.substr( 0, str.length - 1 );
		}
		return retVal;
	}

	var listBaseIndent = 0,
		previousListItemMargin = null,
		previousListId;

	var plugin = ( CKEDITOR.plugins.pastefromword = {
		utils: {
			// Create a &lt;cke:listbullet&gt; which indicate an list item type.
			createListBulletMarker: function( bullet, bulletText ) {
				var marker = new CKEDITOR.htmlParser.element( &#39;cke:listbullet&#39; );
				marker.attributes = { &#39;cke:listsymbol&#39;: bullet[ 0 ] };
				marker.add( new CKEDITOR.htmlParser.text( bulletText ) );
				return marker;
			},

			isListBulletIndicator: function( element ) {
				var styleText = element.attributes &amp;&amp; element.attributes.style;
				if ( /mso-list\s*:\s*Ignore/i.test( styleText ) )
					return true;
			},

			isContainingOnlySpaces: function( element ) {
				var text;
				return ( ( text = element.onlyChild() ) &amp;&amp; ( /^(:?\s|&amp;nbsp;)+$/ ).test( text.value ) );
			},

			resolveList: function( element ) {
				// &lt;cke:listbullet&gt; indicate a list item.
				var attrs = element.attributes,
					listMarker;

				if ( ( listMarker = element.removeAnyChildWithName( &#39;cke:listbullet&#39; ) ) &amp;&amp; listMarker.length &amp;&amp; ( listMarker = listMarker[ 0 ] ) ) {
					element.name = &#39;cke:li&#39;;

					if ( attrs.style ) {
						attrs.style = plugin.filters.stylesFilter( [
							// Text-indent is not representing list item level any more.
							[ &#39;text-indent&#39; ],
							[ &#39;line-height&#39; ],
							// First attempt is to resolve indent level from on a constant margin increment.
							[ ( /^margin(:?-left)?$/ ), null, function( margin ) {
								// Deal with component/short-hand form.
								var values = margin.split( &#39; &#39; );
								margin = CKEDITOR.tools.convertToPx( values[ 3 ] || values[ 1 ] || values[ 0 ] );

								// Figure out the indent unit by checking the first time of incrementation.
								if ( !listBaseIndent &amp;&amp; previousListItemMargin !== null &amp;&amp; margin &gt; previousListItemMargin )
									listBaseIndent = margin - previousListItemMargin;

								previousListItemMargin = margin;

								attrs[ &#39;cke:indent&#39; ] = listBaseIndent &amp;&amp; ( Math.ceil( margin / listBaseIndent ) + 1 ) || 1;
							} ],
							// The best situation: &quot;mso-list:l0 level1 lfo2&quot; tells the belonged list root, list item indentation, etc.
							[ ( /^mso-list$/ ), null, function( val ) {
								val = val.split( &#39; &#39; );
								// Ignore values like &quot;mso-list:Ignore&quot;. (FF #11976)
								if ( val.length &lt; 2 ) {
									return;
								}

								var listId = Number( val[ 0 ].match( /\d+/ ) ),
									indent = Number( val[ 1 ].match( /\d+/ ) );

								if ( indent == 1 ) {
									listId !== previousListId &amp;&amp; ( attrs[ &#39;cke:reset&#39; ] = 1 );
									previousListId = listId;
								}
								attrs[ &#39;cke:indent&#39; ] = indent;
							} ]
						] )( attrs.style, element ) || &#39;&#39;;
					}

					// First level list item might be presented without a margin.


					// In case all above doesn&#39;t apply.
					if ( !attrs[ &#39;cke:indent&#39; ] ) {
						previousListItemMargin = 0;
						attrs[ &#39;cke:indent&#39; ] = 1;
					}

					// Inherit attributes from bullet.
					CKEDITOR.tools.extend( attrs, listMarker.attributes );
					return true;
				}
				// Current list disconnected.
				else {
					previousListId = previousListItemMargin = listBaseIndent = null;
				}

				return false;
			},

			// Providing a shorthand style then retrieve one or more style component values.
			getStyleComponents: ( function() {
				var calculator = CKEDITOR.dom.element.createFromHtml( &#39;&lt;div style=&quot;position:absolute;left:-9999px;top:-9999px;&quot;&gt;&lt;/div&gt;&#39;, CKEDITOR.document );
				CKEDITOR.document.getBody().append( calculator );

				return function( name, styleValue, fetchList ) {
					calculator.setStyle( name, styleValue );
					var styles = {},
						count = fetchList.length;
					for ( var i = 0; i &lt; count; i++ )
						styles[ fetchList[ i ] ] = calculator.getStyle( fetchList[ i ] );

					return styles;
				};
			} )(),

			listDtdParents: CKEDITOR.dtd.parentOf( &#39;ol&#39; )
		},

		filters: {
			// Transform a normal list into flat list items only presentation.
			// E.g. &lt;ul&gt;&lt;li&gt;level1&lt;ol&gt;&lt;li&gt;level2&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt; =&gt;
			// &lt;cke:li cke:listtype=&quot;ul&quot; cke:indent=&quot;1&quot;&gt;level1&lt;/cke:li&gt;
			// &lt;cke:li cke:listtype=&quot;ol&quot; cke:indent=&quot;2&quot;&gt;level2&lt;/cke:li&gt;
			flattenList: function( element, level ) {
				level = typeof level == &#39;number&#39; ? level : 1;

				var attrs = element.attributes,
					listStyleType;

				// All list items are of the same type.
				switch ( attrs.type ) {
					case &#39;a&#39;:
						listStyleType = &#39;lower-alpha&#39;;
						break;
					case &#39;1&#39;:
						listStyleType = &#39;decimal&#39;;
						break;
						// TODO: Support more list style type from MS-Word.
				}

				var children = element.children,
					child;

				for ( var i = 0; i &lt; children.length; i++ ) {
					child = children[ i ];

					if ( child.name in CKEDITOR.dtd.$listItem ) {
						var attributes = child.attributes,
							listItemChildren = child.children,
							count = listItemChildren.length,
							first = listItemChildren[ 0 ],
							last = listItemChildren[ count - 1 ];

						// Converts &lt;li&gt;&lt;p style=&quot;_MSO_LIST_STYLES_&quot;&gt;{...}&lt;/p&gt;&lt;/li&gt; -&gt; &lt;li style=&quot;_MSO_LIST_STYLES_&quot;&gt;{...}&lt;/li&gt;.
						// The above format is what we got when pasting from Word 2010 to IE11 and possibly some others.
						// Existence of extra &lt;p&gt; tag that can be later recognized as list item (see #getRules.return.elements.p)
						// creates incorrect and problematic structures similar to &lt;cke:li&gt;&lt;cke:li&gt;{...}&lt;/cke:li&gt;&lt;/cke:li&gt;. (#11376)
						if ( first.attributes &amp;&amp; first.attributes.style &amp;&amp; first.attributes.style.indexOf( &#39;mso-list&#39; ) &gt; -1 ) {
							child.attributes.style = first.attributes.style;
							first.replaceWithChildren();
						}

						// Move out nested list.
						if ( last.name in CKEDITOR.dtd.$list ) {
							element.add( last, i + 1 );

							// Remove the parent list item if it&#39;s just a holder.
							if ( !--listItemChildren.length )
								children.splice( i--, 1 );
						}

						child.name = &#39;cke:li&#39;;

						// Inherit numbering from list root on the first list item.
						attrs.start &amp;&amp; !i &amp;&amp; ( attributes.value = attrs.start );

						plugin.filters.stylesFilter( [
							[ &#39;tab-stops&#39;, null, function( val ) {
								// val = [left|center|right|decimal] &lt;value&gt;&lt;unit&gt; Source: W3C, WD-tabs-970117.
								// In some cases the first word is missing - hence the square brackets.
								var margin = val.match( /0$|\d+\.?\d*\w+/ );
								margin &amp;&amp; ( previousListItemMargin = CKEDITOR.tools.convertToPx( margin[ 0 ] ) );
							} ],
							( level == 1 ? [ &#39;mso-list&#39;, null, function( val ) {
								val = val.split( &#39; &#39; );
								var listId = Number( val[ 0 ].match( /\d+/ ) );
								listId !== previousListId &amp;&amp; ( attributes[ &#39;cke:reset&#39; ] = 1 );
								previousListId = listId;
							} ] : null )
						] )( attributes.style );

						attributes[ &#39;cke:indent&#39; ] = level;
						attributes[ &#39;cke:listtype&#39; ] = element.name;
						attributes[ &#39;cke:list-style-type&#39; ] = listStyleType;
					}
					// Flatten sub list.
					else if ( child.name in CKEDITOR.dtd.$list ) {
						// Absorb sub list children.
						arguments.callee.apply( this, [ child, level + 1 ] );
						children = children.slice( 0, i ).concat( child.children ).concat( children.slice( i + 1 ) );
						element.children = [];
						for ( var j = 0, num = children.length; j &lt; num; j++ )
							element.add( children[ j ] );

						children = element.children;
					}
				}

				delete element.name;

				// We&#39;re loosing tag name here, signalize this element as a list.
				attrs[ &#39;cke:list&#39; ] = 1;
			},

			// Try to collect all list items among the children and establish one
			// or more HTML list structures for them.
			// @param element
			assembleList: function( element ) {
				var children = element.children,
					child, listItem, // The current processing cke:li element.
					listItemAttrs, listItemIndent, // Indent level of current list item.
					lastIndent, lastListItem, // The previous one just been added to the list.
					list, // Current staging list and it&#39;s parent list if any.
					openedLists = [],
					previousListStyleType, previousListType;

				// Properties of the list item are to be resolved from the list bullet.
				var bullet, listType, listStyleType, itemNumeric;

				for ( var i = 0; i &lt; children.length; i++ ) {
					child = children[ i ];

					if ( child.name == &#39;cke:li&#39; ) {
						child.name = &#39;li&#39;;
						listItem = child;
						listItemAttrs = listItem.attributes;
						bullet = listItemAttrs[ &#39;cke:listsymbol&#39; ];
						bullet = bullet &amp;&amp; bullet.match( /^(?:[(]?)([^\s]+?)([.)]?)$/ );
						listType = listStyleType = itemNumeric = null;

						if ( listItemAttrs[ &#39;cke:ignored&#39; ] ) {
							children.splice( i--, 1 );
							continue;
						}


						// This&#39;s from a new list root.
						listItemAttrs[ &#39;cke:reset&#39; ] &amp;&amp; ( list = lastIndent = lastListItem = null );

						// List item indent level might come from a real list indentation or
						// been resolved from a pseudo list item&#39;s margin value, even get
						// no indentation at all.
						listItemIndent = Number( listItemAttrs[ &#39;cke:indent&#39; ] );

						// We&#39;re moving out of the current list, cleaning up.
						if ( listItemIndent != lastIndent )
							previousListType = previousListStyleType = null;

						// List type and item style are already resolved.
						if ( !bullet ) {
							listType = listItemAttrs[ &#39;cke:listtype&#39; ] || &#39;ol&#39;;
							listStyleType = listItemAttrs[ &#39;cke:list-style-type&#39; ];
						} else {
							// Probably share the same list style type with previous list item,
							// give it priority to avoid ambiguous between C(Alpha) and C.(Roman).
							if ( previousListType &amp;&amp; listMarkerPatterns[ previousListType ][ previousListStyleType ].test( bullet[ 1 ] ) ) {
								listType = previousListType;
								listStyleType = previousListStyleType;
							} else {
								for ( var type in listMarkerPatterns ) {
									for ( var style in listMarkerPatterns[ type ] ) {
										if ( listMarkerPatterns[ type ][ style ].test( bullet[ 1 ] ) ) {
											// Small numbering has higher priority, when dealing with ambiguous
											// between C(Alpha) and C.(Roman).
											if ( type == &#39;ol&#39; &amp;&amp; ( /alpha|roman/ ).test( style ) ) {
												var num = /roman/.test( style ) ? fromRoman( bullet[ 1 ] ) : fromAlphabet( bullet[ 1 ] );
												if ( !itemNumeric || num &lt; itemNumeric ) {
													itemNumeric = num;
													listType = type;
													listStyleType = style;
												}
											} else {
												listType = type;
												listStyleType = style;
												break;
											}
										}
									}
								}
							}

							// Simply use decimal/disc for the rest forms of unrepresentable
							// numerals, e.g. Chinese..., but as long as there a second part
							// included, it has a bigger chance of being a order list ;)
							!listType &amp;&amp; ( listType = bullet[ 2 ] ? &#39;ol&#39; : &#39;ul&#39; );
						}

						previousListType = listType;
						previousListStyleType = listStyleType || ( listType == &#39;ol&#39; ? &#39;decimal&#39; : &#39;disc&#39; );
						if ( listStyleType &amp;&amp; listStyleType != ( listType == &#39;ol&#39; ? &#39;decimal&#39; : &#39;disc&#39; ) )
							listItem.addStyle( &#39;list-style-type&#39;, listStyleType );

						// Figure out start numbering.
						if ( listType == &#39;ol&#39; &amp;&amp; bullet ) {
							switch ( listStyleType ) {
								case &#39;decimal&#39;:
									itemNumeric = Number( bullet[ 1 ] );
									break;
								case &#39;lower-roman&#39;:
								case &#39;upper-roman&#39;:
									itemNumeric = fromRoman( bullet[ 1 ] );
									break;
								case &#39;lower-alpha&#39;:
								case &#39;upper-alpha&#39;:
									itemNumeric = fromAlphabet( bullet[ 1 ] );
									break;
							}

							// Always create the numbering, swipe out unnecessary ones later.
							listItem.attributes.value = itemNumeric;
						}

						// Start the list construction.
						if ( !list ) {
							openedLists.push( list = new CKEDITOR.htmlParser.element( listType ) );
							list.add( listItem );
							children[ i ] = list;
						} else {
							if ( listItemIndent &gt; lastIndent ) {
								openedLists.push( list = new CKEDITOR.htmlParser.element( listType ) );
								list.add( listItem );
								lastListItem.add( list );
							} else if ( listItemIndent &lt; lastIndent ) {
								// There might be a negative gap between two list levels. (#4944)
								var diff = lastIndent - listItemIndent,
									parent;
								while ( diff-- &amp;&amp; ( parent = list.parent ) )
									list = parent.parent;

								list.add( listItem );
							} else {
								list.add( listItem );
							}

							children.splice( i--, 1 );
						}

						lastListItem = listItem;
						lastIndent = listItemIndent;
					} else if ( list ) {
						list = lastIndent = lastListItem = null;
					}
				}

				for ( i = 0; i &lt; openedLists.length; i++ )
					postProcessList( openedLists[ i ] );

				list = lastIndent = lastListItem = previousListId = previousListItemMargin = listBaseIndent = null;
			},

			// A simple filter which always rejecting.
			falsyFilter: function() {
				return false;
			},

			// A filter dedicated on the &#39;style&#39; attribute filtering, e.g. dropping/replacing style properties.
			// @param styles {Array} in form of [ styleNameRegexp, styleValueRegexp,
			// newStyleValue/newStyleGenerator, newStyleName ] where only the first
			// parameter is mandatory.
			// @param whitelist {Boolean} Whether the {@param styles} will be considered as a white-list.
			stylesFilter: function( styles, whitelist ) {
				return function( styleText, element ) {
					var rules = [];
					// html-encoded quote might be introduced by &#39;font-family&#39;
					// from MS-Word which confused the following regexp. e.g.
					//&#39;font-family: &amp;quot;Lucida, Console&amp;quot;&#39;
					( styleText || &#39;&#39; ).replace( /&amp;quot;/g, &#39;&quot;&#39; ).replace( /\s*([^ :;]+)\s*:\s*([^;]+)\s*(?=;|$)/g, function( match, name, value ) {
						name = name.toLowerCase();
						name == &#39;font-family&#39; &amp;&amp; ( value = value.replace( /[&quot;&#39;]/g, &#39;&#39; ) );

						var namePattern, valuePattern, newValue, newName;
						for ( var i = 0; i &lt; styles.length; i++ ) {
							if ( styles[ i ] ) {
								namePattern = styles[ i ][ 0 ];
								valuePattern = styles[ i ][ 1 ];
								newValue = styles[ i ][ 2 ];
								newName = styles[ i ][ 3 ];

								if ( name.match( namePattern ) &amp;&amp; ( !valuePattern || value.match( valuePattern ) ) ) {
									name = newName || name;
									whitelist &amp;&amp; ( newValue = newValue || value );

									if ( typeof newValue == &#39;function&#39; )
										newValue = newValue( value, element, name );

									// Return an couple indicate both name and value
									// changed.
									if ( newValue &amp;&amp; newValue.push )
										name = newValue[ 0 ], newValue = newValue[ 1 ];

									if ( typeof newValue == &#39;string&#39; )
										rules.push( [ name, newValue ] );
									return;
								}
							}
						}

						!whitelist &amp;&amp; rules.push( [ name, value ] );

					} );

					for ( var i = 0; i &lt; rules.length; i++ )
						rules[ i ] = rules[ i ].join( &#39;:&#39; );
					return rules.length ? ( rules.join( &#39;;&#39; ) + &#39;;&#39; ) : false;
				};
			},

			// Migrate the element by decorate styles on it.
			// @param styleDefinition
			// @param variables
			elementMigrateFilter: function( styleDefinition, variables ) {
				return styleDefinition ? function( element ) {
					var styleDef = variables ? new CKEDITOR.style( styleDefinition, variables )._.definition : styleDefinition;
					element.name = styleDef.element;
					CKEDITOR.tools.extend( element.attributes, CKEDITOR.tools.clone( styleDef.attributes ) );
					element.addStyle( CKEDITOR.style.getStyleText( styleDef ) );
					// Mark style classes as allowed so they will not be filtered out (#12256).
					if ( styleDef.attributes &amp;&amp; styleDef.attributes[ &#39;class&#39; ] ) {
						element.classWhiteList = &#39; &#39; + styleDef.attributes[ &#39;class&#39; ] + &#39; &#39;;
					}
				} : function() {};
			},

			// Migrate styles by creating a new nested stylish element.
			// @param styleDefinition
			styleMigrateFilter: function( styleDefinition, variableName ) {

				var elementMigrateFilter = this.elementMigrateFilter;
				return styleDefinition ? function( value, element ) {
					// Build an stylish element first.
					var styleElement = new CKEDITOR.htmlParser.element( null ),
						variables = {};

					variables[ variableName ] = value;
					elementMigrateFilter( styleDefinition, variables )( styleElement );
					// Place the new element inside the existing span.
					styleElement.children = element.children;
					element.children = [ styleElement ];

					// #10285 - later on styleElement will replace element if element won&#39;t have any attributes.
					// However, in some cases styleElement is identical to element and therefore should not be filtered
					// to avoid inf loop. Unfortunately calling element.filterChildren() does not prevent from that (#10327).
					// However, we can assume that we don&#39;t need to filter styleElement at all, so it is safe to replace
					// its filter method.
					styleElement.filter = function() {};
					styleElement.parent = element;
				} : function() {};
			},

			// A filter which remove cke-namespaced-attribute on
			// all none-cke-namespaced elements.
			// @param value
			// @param element
			bogusAttrFilter: function( value, element ) {
				if ( element.name.indexOf( &#39;cke:&#39; ) == -1 )
					return false;
			},

			// A filter which will be used to apply inline css style according the stylesheet
			// definition rules, is generated lazily when filtering.
			applyStyleFilter: null

		},

		getRules: function( editor, filter ) {
			var dtd = CKEDITOR.dtd,
				blockLike = CKEDITOR.tools.extend( {}, dtd.$block, dtd.$listItem, dtd.$tableContent ),
				config = editor.config,
				filters = this.filters,
				falsyFilter = filters.falsyFilter,
				stylesFilter = filters.stylesFilter,
				elementMigrateFilter = filters.elementMigrateFilter,
				styleMigrateFilter = CKEDITOR.tools.bind( this.filters.styleMigrateFilter, this.filters ),
				createListBulletMarker = this.utils.createListBulletMarker,
				flattenList = filters.flattenList,
				assembleList = filters.assembleList,
				isListBulletIndicator = this.utils.isListBulletIndicator,
				containsNothingButSpaces = this.utils.isContainingOnlySpaces,
				resolveListItem = this.utils.resolveList,
				convertToPx = function( value ) {
					value = CKEDITOR.tools.convertToPx( value );
					return isNaN( value ) ? value : value + &#39;px&#39;;
				},
				getStyleComponents = this.utils.getStyleComponents,
				listDtdParents = this.utils.listDtdParents,
				removeFontStyles = config.pasteFromWordRemoveFontStyles !== false,
				removeStyles = config.pasteFromWordRemoveStyles !== false;

			return {

				elementNames: [
					// Remove script, meta and link elements.
					[ ( /meta|link|script/ ), &#39;&#39; ]
				],

				root: function( element ) {
					element.filterChildren( filter );
					assembleList( element );
				},

				elements: {
					&#39;^&#39;: function( element ) {
						// Transform CSS style declaration to inline style.
						var applyStyleFilter;
						if ( CKEDITOR.env.gecko &amp;&amp; ( applyStyleFilter = filters.applyStyleFilter ) )
							applyStyleFilter( element );
					},

					$: function( element ) {
						var tagName = element.name || &#39;&#39;,
							attrs = element.attributes;

						// Convert length unit of width/height on blocks to
						// a more editor-friendly way (px).
						if ( tagName in blockLike &amp;&amp; attrs.style )
							attrs.style = stylesFilter( [ [ ( /^(:?width|height)$/ ), null, convertToPx ] ] )( attrs.style ) || &#39;&#39;;

						// Processing headings.
						if ( tagName.match( /h\d/ ) ) {
							element.filterChildren( filter );
							// Is the heading actually a list item?
							if ( resolveListItem( element ) )
								return;

							// Adapt heading styles to editor&#39;s convention.
							elementMigrateFilter( config[ &#39;format_&#39; + tagName ] )( element );
						}
						// Remove inline elements which contain only empty spaces.
						else if ( tagName in dtd.$inline ) {
							element.filterChildren( filter );
							if ( containsNothingButSpaces( element ) )
								delete element.name;
						}
						// Remove element with ms-office namespace,
						// with it&#39;s content preserved, e.g. &#39;o:p&#39;.
						else if ( tagName.indexOf( &#39;:&#39; ) != -1 &amp;&amp; tagName.indexOf( &#39;cke&#39; ) == -1 ) {
							element.filterChildren( filter );

							// Restore image real link from vml.
							if ( tagName == &#39;v:imagedata&#39; ) {
								var href = element.attributes[ &#39;o:href&#39; ];
								if ( href )
									element.attributes.src = href;
								element.name = &#39;img&#39;;
								return;
							}
							delete element.name;
						}

						// Assembling list items into a whole list.
						if ( tagName in listDtdParents ) {
							element.filterChildren( filter );
							assembleList( element );
						}
					},

					// We&#39;ll drop any style sheet, but Firefox conclude
					// certain styles in a single style element, which are
					// required to be changed into inline ones.
					&#39;style&#39;: function( element ) {
						if ( CKEDITOR.env.gecko ) {
							// Grab only the style definition section.
							var styleDefSection = element.onlyChild().value.match( /\/\* Style Definitions \*\/([\s\S]*?)\/\*/ ),
								styleDefText = styleDefSection &amp;&amp; styleDefSection[ 1 ],
								rules = {}; // Storing the parsed result.

							if ( styleDefText ) {
								styleDefText
								// Remove line-breaks.
								.replace( /[\n\r]/g, &#39;&#39; )
								// Extract selectors and style properties.
								.replace( /(.+?)\{(.+?)\}/g, function( rule, selectors, styleBlock ) {
									selectors = selectors.split( &#39;,&#39; );
									var length = selectors.length;
									for ( var i = 0; i &lt; length; i++ ) {
										// Assume MS-Word mostly generate only simple
										// selector( [Type selector][Class selector]).
										CKEDITOR.tools.trim( selectors[ i ] ).replace( /^(\w+)(\.[\w-]+)?$/g, function( match, tagName, className ) {
											tagName = tagName || &#39;*&#39;;
											className = className.substring( 1, className.length );

											// Reject MS-Word Normal styles.
											if ( className.match( /MsoNormal/ ) )
												return;

											if ( !rules[ tagName ] )
												rules[ tagName ] = {};
											if ( className )
												rules[ tagName ][ className ] = styleBlock;
											else
												rules[ tagName ] = styleBlock;
										} );
									}
								} );

								filters.applyStyleFilter = function( element ) {
									var name = rules[ &#39;*&#39; ] ? &#39;*&#39; : element.name,
										className = element.attributes &amp;&amp; element.attributes[ &#39;class&#39; ],
										style;
									if ( name in rules ) {
										style = rules[ name ];
										if ( typeof style == &#39;object&#39; )
											style = style[ className ];
										// Maintain style rules priorities.
										style &amp;&amp; element.addStyle( style, true );
									}
								};
							}
						}
						return false;
					},

					&#39;p&#39;: function( element ) {
						// A a fall-back approach to resolve list item in browsers
						// that doesn&#39;t include &quot;mso-list:Ignore&quot; on list bullets,
						// note it&#39;s not perfect as not all list style (e.g. &quot;heading list&quot;) is shipped
						// with this pattern. (#6662)
						if ( ( /MsoListParagraph/i ).exec( element.attributes[ &#39;class&#39; ] ) ||
							( element.getStyle( &#39;mso-list&#39; ) &amp;&amp; !element.getStyle( &#39;mso-list&#39; ).match( /^(none|skip)$/i ) ) ) {
							var bulletText = element.firstChild( function( node ) {
								return node.type == CKEDITOR.NODE_TEXT &amp;&amp; !containsNothingButSpaces( node.parent );
							} );

							var bullet = bulletText &amp;&amp; bulletText.parent;
							if ( bullet )
								bullet.addStyle( &#39;mso-list&#39;, &#39;Ignore&#39; );

						}

						element.filterChildren( filter );

						// Is the paragraph actually a list item?
						if ( resolveListItem( element ) )
							return;

						// Adapt paragraph formatting to editor&#39;s convention
						// according to enter-mode.
						if ( config.enterMode == CKEDITOR.ENTER_BR ) {
							// We suffer from attribute/style lost in this situation.
							delete element.name;
							element.add( new CKEDITOR.htmlParser.element( &#39;br&#39; ) );
						} else {
							elementMigrateFilter( config[ &#39;format_&#39; + ( config.enterMode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39; ) ] )( element );
						}
					},

					&#39;div&#39;: function( element ) {
						// Aligned table with no text surrounded is represented by a wrapper div, from which
						// table cells inherit as text-align styles, which is wrong.
						// Instead we use a clear-float div after the table to properly achieve the same layout.
						var singleChild = element.onlyChild();
						if ( singleChild &amp;&amp; singleChild.name == &#39;table&#39; ) {
							var attrs = element.attributes;
							singleChild.attributes = CKEDITOR.tools.extend( singleChild.attributes, attrs );
							attrs.style &amp;&amp; singleChild.addStyle( attrs.style );

							var clearFloatDiv = new CKEDITOR.htmlParser.element( &#39;div&#39; );
							clearFloatDiv.addStyle( &#39;clear&#39;, &#39;both&#39; );
							element.add( clearFloatDiv );
							delete element.name;
						}
					},

					&#39;td&#39;: function( element ) {
						// &#39;td&#39; in &#39;thead&#39; is actually &lt;th&gt;.
						if ( element.getAncestor( &#39;thead&#39; ) )
							element.name = &#39;th&#39;;
					},

					// MS-Word sometimes present list as a mixing of normal list
					// and pseudo-list, normalize the previous ones into pseudo form.
					&#39;ol&#39;: flattenList,
					&#39;ul&#39;: flattenList,
					&#39;dl&#39;: flattenList,

					&#39;font&#39;: function( element ) {
						// Drop the font tag if it comes from list bullet text.
						if ( isListBulletIndicator( element.parent ) ) {
							delete element.name;
							return;
						}

						element.filterChildren( filter );

						var attrs = element.attributes,
							styleText = attrs.style,
							parent = element.parent;

						if ( parent.name == &#39;font&#39; ) { // Merge nested &lt;font&gt; tags.
							CKEDITOR.tools.extend( parent.attributes, element.attributes );
							styleText &amp;&amp; parent.addStyle( styleText );
							delete element.name;
						}
						// Convert the merged into a span with all attributes preserved.
						else {
							// Use array to avoid string concatenation and get rid of problems with trailing &quot;;&quot; (#12243).
							styleText = ( styleText || &#39;&#39; ).split( &#39;;&#39; );

							// IE&#39;s having those deprecated attributes, normalize them.
							if ( attrs.color ) {
								if ( attrs.color != &#39;#000000&#39; )
									styleText.push( &#39;color:&#39; + attrs.color );
								delete attrs.color;
							}
							if ( attrs.face ) {
								styleText.push( &#39;font-family:&#39; + attrs.face );
								delete attrs.face;
							}
							// TODO: Mapping size in ranges of xx-small,
							// x-small, small, medium, large, x-large, xx-large.
							if ( attrs.size ) {
								styleText.push( &#39;font-size:&#39; +
									( attrs.size &gt; 3 ? &#39;large&#39; : ( attrs.size &lt; 3 ? &#39;small&#39; : &#39;medium&#39; ) ) );
								delete attrs.size;
							}

							element.name = &#39;span&#39;;
							element.addStyle( styleText.join( &#39;;&#39; ) );
						}
					},

					&#39;span&#39;: function( element ) {
						// Remove the span if it comes from list bullet text.
						if ( isListBulletIndicator( element.parent ) )
							return false;

						element.filterChildren( filter );
						if ( containsNothingButSpaces( element ) ) {
							delete element.name;
							return null;
						}

						// List item bullet type is supposed to be indicated by
						// the text of a span with style &#39;mso-list : Ignore&#39; or an image.
						if ( isListBulletIndicator( element ) ) {
							var listSymbolNode = element.firstChild( function( node ) {
								return node.value || node.name == &#39;img&#39;;
							} );

							var listSymbol = listSymbolNode &amp;&amp; ( listSymbolNode.value || &#39;l.&#39; ),
								listType = listSymbol &amp;&amp; listSymbol.match( /^(?:[(]?)([^\s]+?)([.)]?)$/ );

							if ( listType ) {
								var marker = createListBulletMarker( listType, listSymbol );
								// Some non-existed list items might be carried by an inconsequential list, indicate by &quot;mso-hide:all/display:none&quot;,
								// those are to be removed later, now mark it with &quot;cke:ignored&quot;.
								var ancestor = element.getAncestor( &#39;span&#39; );
								if ( ancestor &amp;&amp; ( / mso-hide:\s*all|display:\s*none / ).test( ancestor.attributes.style ) )
									marker.attributes[ &#39;cke:ignored&#39; ] = 1;
								return marker;
							}
						}

						// Update the src attribute of image element with href.
						var attrs = element.attributes,
							styleText = attrs &amp;&amp; attrs.style;

						// Assume MS-Word mostly carry font related styles on &lt;span&gt;,
						// adapting them to editor&#39;s convention.
						if ( styleText ) {
							attrs.style = stylesFilter( [
								// Drop &#39;inline-height&#39; style which make lines overlapping.
								[ &#39;line-height&#39; ],
								[ ( /^font-family$/ ), null, !removeFontStyles ? styleMigrateFilter( config.font_style, &#39;family&#39; ) : null ],
								[ ( /^font-size$/ ), null, !removeFontStyles ? styleMigrateFilter( config.fontSize_style, &#39;size&#39; ) : null ],
								[ ( /^color$/ ), null, !removeFontStyles ? styleMigrateFilter( config.colorButton_foreStyle, &#39;color&#39; ) : null ],
								[ ( /^background-color$/ ), null, !removeFontStyles ? styleMigrateFilter( config.colorButton_backStyle, &#39;color&#39; ) : null ]
							] )( styleText, element ) || &#39;&#39;;
						}

						if ( !attrs.style )
							delete attrs.style;

						if ( CKEDITOR.tools.isEmpty( attrs ) )
							delete element.name;

						return null;
					},

					// Migrate basic style formats to editor configured ones.
					b: elementMigrateFilter( config.coreStyles_bold ),
					i: elementMigrateFilter( config.coreStyles_italic ),
					u: elementMigrateFilter( config.coreStyles_underline ),
					s: elementMigrateFilter( config.coreStyles_strike ),
					sup: elementMigrateFilter( config.coreStyles_superscript ),
					sub: elementMigrateFilter( config.coreStyles_subscript ),

					// Remove full paths from links to anchors.
					a: function( element ) {
						var attrs = element.attributes;

						if ( attrs.name &amp;&amp; attrs.name.match( /ole_link\d+/i ) ) {
							delete element.name;
							return;
						}

						if ( attrs.href &amp;&amp; attrs.href.match( /^file:\/\/\/[\S]+#/i ) )
							attrs.href = attrs.href.replace( /^file:\/\/\/[^#]+/i, &#39;&#39; );
					},

					&#39;cke:listbullet&#39;: function( element ) {
						if ( element.getAncestor( /h\d/ ) &amp;&amp; !config.pasteFromWordNumberedHeadingToList )
							delete element.name;
					}
				},

				attributeNames: [
					// Remove onmouseover and onmouseout events (from MS Word comments effect)
					[ ( /^onmouse(:?out|over)/ ), &#39;&#39; ],
					// Onload on image element.
					[ ( /^onload$/ ), &#39;&#39; ],
					// Remove office and vml attribute from elements.
					[ ( /(?:v|o):\w+/ ), &#39;&#39; ],
					// Remove lang/language attributes.
					[ ( /^lang/ ), &#39;&#39; ]
				],

				attributes: {
					&#39;style&#39;: stylesFilter( removeStyles ?
					// Provide a white-list of styles that we preserve, those should
					// be the ones that could later be altered with editor tools.
					[
						// Leave list-style-type
						[ ( /^list-style-type$/ ), null ],

						// Preserve margin-left/right which used as default indent style in the editor.
						[ ( /^margin$|^margin-(?!bottom|top)/ ), null, function( value, element, name ) {
							if ( element.name in { p: 1, div: 1 } ) {
								var indentStyleName = config.contentsLangDirection == &#39;ltr&#39; ? &#39;margin-left&#39; : &#39;margin-right&#39;;

								// Extract component value from &#39;margin&#39; shorthand.
								if ( name == &#39;margin&#39; )
									value = getStyleComponents( name, value, [ indentStyleName ] )[ indentStyleName ];
								else if ( name != indentStyleName )
									return null;

								if ( value &amp;&amp; !emptyMarginRegex.test( value ) )
									return [ indentStyleName, value ];
							}

							return null;
						} ],

						// Preserve clear float style.
						[ ( /^clear$/ ) ],

						[ ( /^border.*|margin.*|vertical-align|float$/ ), null, function( value, element ) {
							if ( element.name == &#39;img&#39; )
								return value;
						} ],

						[ ( /^width|height$/ ), null, function( value, element ) {
							if ( element.name in { table: 1, td: 1, th: 1, img: 1 } )
								return value;
						} ]
					] :
					// Otherwise provide a black-list of styles that we remove.
					[
						[ ( /^mso-/ ) ],
						// Fixing color values.
						[ ( /-color$/ ), null, function( value ) {
							if ( value == &#39;transparent&#39; )
								return false;
							if ( CKEDITOR.env.gecko )
								return value.replace( /-moz-use-text-color/g, &#39;transparent&#39; );
						} ],
						// Remove empty margin values, e.g. 0.00001pt 0em 0pt
						[ ( /^margin$/ ), emptyMarginRegex ],
						[ &#39;text-indent&#39;, &#39;0cm&#39; ],
						[ &#39;page-break-before&#39; ],
						[ &#39;tab-stops&#39; ],
						[ &#39;display&#39;, &#39;none&#39; ],
						removeFontStyles ? [ ( /font-?/ ) ] : null
					], removeStyles ),

					// Prefer width styles over &#39;width&#39; attributes.
					&#39;width&#39;: function( value, element ) {
						if ( element.name in dtd.$tableContent )
							return false;
					},
					// Prefer border styles over table &#39;border&#39; attributes.
					&#39;border&#39;: function( value, element ) {
						if ( element.name in dtd.$tableContent )
							return false;
					},

					// Only Firefox carry style sheet from MS-Word, which
					// will be applied by us manually. For other browsers
					// the css className is useless.
					// We need to keep classes added as a style (#12256).
					&#39;class&#39;: function( value, element ) {
						if ( element.classWhiteList &amp;&amp; element.classWhiteList.indexOf( &#39; &#39; + value + &#39; &#39; ) != -1 ) {
							return value;
						}
						return false;
					},

					// MS-Word always generate &#39;background-color&#39; along with &#39;bgcolor&#39;,
					// simply drop the deprecated attributes.
					&#39;bgcolor&#39;: falsyFilter,

					// Deprecate &#39;valign&#39; attribute in favor of &#39;vertical-align&#39;.
					&#39;valign&#39;: removeStyles ? falsyFilter : function( value, element ) {
						element.addStyle( &#39;vertical-align&#39;, value );
						return false;
					}
				},

				// Fore none-IE, some useful data might be buried under these IE-conditional
				// comments where RegExp were the right approach to dig them out where usual approach
				// is transform it into a fake element node which hold the desired data.
				comment: !CKEDITOR.env.ie ? function( value, node ) {
					var imageInfo = value.match( /&lt;img.*?&gt;/ ),
						listInfo = value.match( /^\[if !supportLists\]([\s\S]*?)\[endif\]$/ );

					// Seek for list bullet indicator.
					if ( listInfo ) {
						// Bullet symbol could be either text or an image.
						var listSymbol = listInfo[ 1 ] || ( imageInfo &amp;&amp; &#39;l.&#39; ),
							listType = listSymbol &amp;&amp; listSymbol.match( /&gt;(?:[(]?)([^\s]+?)([.)]?)&lt;/ );
						return createListBulletMarker( listType, listSymbol );
					}

					// Reveal the &lt;img&gt; element in conditional comments for Firefox.
					if ( CKEDITOR.env.gecko &amp;&amp; imageInfo ) {
						var img = CKEDITOR.htmlParser.fragment.fromHtml( imageInfo[ 0 ] ).children[ 0 ],
							previousComment = node.previous,
							// Try to dig the real image link from vml markup from previous comment text.
							imgSrcInfo = previousComment &amp;&amp; previousComment.value.match( /&lt;v:imagedata[^&gt;]*o:href=[&#39;&quot;](.*?)[&#39;&quot;]/ ),
							imgSrc = imgSrcInfo &amp;&amp; imgSrcInfo[ 1 ];

						// Is there a real &#39;src&#39; url to be used?
						imgSrc &amp;&amp; ( img.attributes.src = imgSrc );
						return img;
					}

					return false;
				} : falsyFilter
			};
		}
	} );

	// The paste processor here is just a reduced copy of html data processor.
	var pasteProcessor = function() {
			this.dataFilter = new CKEDITOR.htmlParser.filter();
		};

	pasteProcessor.prototype = {
		toHtml: function( data ) {
			var fragment = CKEDITOR.htmlParser.fragment.fromHtml( data ),
				writer = new CKEDITOR.htmlParser.basicWriter();

			fragment.writeHtml( writer, this.dataFilter );
			return writer.getHtml( true );
		}
	};

	CKEDITOR.cleanWord = function( data, editor ) {
		// We get &lt;![if !supportLists]&gt; and &lt;![endif]&gt; when we started using `dataTransfer` instead of pasteBin, so we need to
		// change &lt;![if !supportLists]&gt; to &lt;!--[if !supportLists]--&gt; and &lt;![endif]&gt; to &lt;!--[endif]--&gt;.
		data = data.replace( /&lt;!\[([^\]]*?)\]&gt;/g, &#39;&lt;!--[$1]--&gt;&#39; );

		// Firefox will be confused by those downlevel-revealed IE conditional
		// comments, fixing them first( convert it to upperlevel-revealed one ).
		// e.g. &lt;![if !vml]&gt;...&lt;![endif]&gt;
		if ( CKEDITOR.env.gecko )
			data = data.replace( /(&lt;!--\[if[^&lt;]*?\])--&gt;([\S\s]*?)&lt;!--(\[endif\]--&gt;)/gi, &#39;$1$2$3&#39; );

		// #9456 - Webkit doesn&#39;t wrap list number with span, which is crucial for filter to recognize list.
		//
		//		&lt;p class=&quot;MsoListParagraphCxSpLast&quot; style=&quot;text-indent:-18.0pt;mso-list:l0 level1 lfo2&quot;&gt;
		//			&lt;!--[if !supportLists]--&gt;
		//			3.&lt;span style=&quot;font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;
		//			&lt;!--[endif]--&gt;Test3&lt;o:p&gt;&lt;/o:p&gt;
		//		&lt;/p&gt;
		//
		// Transform to:
		//
		//		&lt;p class=&quot;MsoListParagraphCxSpLast&quot; style=&quot;text-indent:-18.0pt;mso-list:l0 level1 lfo2&quot;&gt;
		//			&lt;!--[if !supportLists]--&gt;
		//			&lt;span&gt;
		//				3.&lt;span style=&quot;font-size: 7pt; line-height: normal; font-family: &#39;Times New Roman&#39;;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;
		//			&lt;/span&gt;
		//			&lt;!--[endif]--&gt;Test3&lt;o:p&gt;&lt;/o:p&gt;
		//		&lt;/p&gt;
		if ( CKEDITOR.env.webkit )
			data = data.replace( /(class=&quot;MsoListParagraph[^&gt;]+&gt;&lt;!--\[if !supportLists\]--&gt;)([^&lt;]+&lt;span[^&lt;]+&lt;\/span&gt;)(&lt;!--\[endif\]--&gt;)/gi, &#39;$1&lt;span&gt;$2&lt;/span&gt;$3&#39; );

		var dataProcessor = new pasteProcessor(),
			dataFilter = dataProcessor.dataFilter;

		// These rules will have higher priorities than default ones.
		dataFilter.addRules( CKEDITOR.plugins.pastefromword.getRules( editor, dataFilter ) );

		// Allow extending data filter rules.
		editor.fire( &#39;beforeCleanWord&#39;, { filter: dataFilter } );

		try {
			data = dataProcessor.toHtml( data );
		} catch ( e ) {
			editor.showNotification( editor.lang.pastefromword.error );
		}

		// Below post processing those things that are unable to delivered by filter rules.

		// Remove &#39;cke&#39; namespaced attribute used in filter rules as marker.
		data = data.replace( /cke:.*?&quot;.*?&quot;/g, &#39;&#39; );

		// Remove empty style attribute.
		data = data.replace( /style=&quot;&quot;/g, &#39;&#39; );

		// Remove the dummy spans ( having no inline style ).
		data = data.replace( /&lt;span&gt;/g, &#39;&#39; );

		return data;
	};
} )();

<span id='CKEDITOR-config-cfg-pasteFromWordRemoveFontStyles'>/**
</span> * Whether to ignore all font related formatting styles, including:
 *
 * * font size;
 * * font family;
 * * font foreground/background color.
 *
 *		config.pasteFromWordRemoveFontStyles = false;
 *
 * @since 3.1
 * @cfg {Boolean} [pasteFromWordRemoveFontStyles=true]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-pasteFromWordNumberedHeadingToList'>/**
</span> * Whether to transform MS Word outline numbered headings into lists.
 *
 *		config.pasteFromWordNumberedHeadingToList = true;
 *
 * @since 3.1
 * @cfg {Boolean} [pasteFromWordNumberedHeadingToList=false]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-pasteFromWordRemoveStyles'>/**
</span> * Whether to remove element styles that can&#39;t be managed with the editor. Note
 * that this doesn&#39;t handle the font specific styles, which depends on the
 * {@link #pasteFromWordRemoveFontStyles} setting instead.
 *
 *		config.pasteFromWordRemoveStyles = false;
 *
 * @since 3.1
 * @cfg {Boolean} [pasteFromWordRemoveStyles=true]
 * @member CKEDITOR.config
 */
</pre>
</body>
</html>
