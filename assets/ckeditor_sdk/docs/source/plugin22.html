<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

<span id='global-property-'>/**
</span> * @fileOverview The Dialog User Interface plugin.
 */

CKEDITOR.plugins.add( &#39;dialogui&#39;, {
	onLoad: function() {

		var initPrivateObject = function( elementDefinition ) {
				this._ || ( this._ = {} );
				this._[ &#39;default&#39; ] = this._.initValue = elementDefinition[ &#39;default&#39; ] || &#39;&#39;;
				this._.required = elementDefinition.required || false;
				var args = [ this._ ];
				for ( var i = 1; i &lt; arguments.length; i++ )
					args.push( arguments[ i ] );
				args.push( true );
				CKEDITOR.tools.extend.apply( CKEDITOR.tools, args );
				return this._;
			},
			textBuilder = {
				build: function( dialog, elementDefinition, output ) {
					return new CKEDITOR.ui.dialog.textInput( dialog, elementDefinition, output );
				}
			},
			commonBuilder = {
				build: function( dialog, elementDefinition, output ) {
					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, elementDefinition, output );
				}
			},
			containerBuilder = {
				build: function( dialog, elementDefinition, output ) {
					var children = elementDefinition.children,
						child,
						childHtmlList = [],
						childObjList = [];
					for ( var i = 0;
					( i &lt; children.length &amp;&amp; ( child = children[ i ] ) ); i++ ) {
						var childHtml = [];
						childHtmlList.push( childHtml );
						childObjList.push( CKEDITOR.dialog._.uiElementBuilders[ child.type ].build( dialog, child, childHtml ) );
					}
					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, childObjList, childHtmlList, output, elementDefinition );
				}
			},
			commonPrototype = {
				isChanged: function() {
					return this.getValue() != this.getInitValue();
				},

				reset: function( noChangeEvent ) {
					this.setValue( this.getInitValue(), noChangeEvent );
				},

				setInitValue: function() {
					this._.initValue = this.getValue();
				},

				resetInitValue: function() {
					this._.initValue = this._[ &#39;default&#39; ];
				},

				getInitValue: function() {
					return this._.initValue;
				}
			},
			commonEventProcessors = CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {
				onChange: function( dialog, func ) {
					if ( !this._.domOnChangeRegistered ) {
						dialog.on( &#39;load&#39;, function() {
							this.getInputElement().on( &#39;change&#39;, function() {
								// Make sure &#39;onchange&#39; doesn&#39;t get fired after dialog closed. (#5719)
								if ( !dialog.parts.dialog.isVisible() )
									return;

								this.fire( &#39;change&#39;, { value: this.getValue() } );
							}, this );
						}, this );
						this._.domOnChangeRegistered = true;
					}

					this.on( &#39;change&#39;, func );
				}
			}, true ),
			eventRegex = /^on([A-Z]\w+)/,
			cleanInnerDefinition = function( def ) {
				// An inner UI element should not have the parent&#39;s type, title or events.
				for ( var i in def ) {
					if ( eventRegex.test( i ) || i == &#39;title&#39; || i == &#39;type&#39; )
						delete def[ i ];
				}
				return def;
			},
			// @context {CKEDITOR.dialog.uiElement} UI element (textarea or textInput)
			// @param {CKEDITOR.dom.event} evt
			toggleBidiKeyUpHandler = function( evt ) {
				var keystroke = evt.data.getKeystroke();

				// ALT + SHIFT + Home for LTR direction.
				if ( keystroke == CKEDITOR.SHIFT + CKEDITOR.ALT + 36 )
					this.setDirectionMarker( &#39;ltr&#39; );

				// ALT + SHIFT + End for RTL direction.
				else if ( keystroke == CKEDITOR.SHIFT + CKEDITOR.ALT + 35 )
					this.setDirectionMarker( &#39;rtl&#39; );
			};

		CKEDITOR.tools.extend( CKEDITOR.ui.dialog, {
<span id='CKEDITOR-ui-dialog-labeledElement-method-constructor'><span id='CKEDITOR-ui-dialog-labeledElement'>			/**
</span></span>			 * Base class for all dialog window elements with a textual label on the left.
			 *
			 * @class CKEDITOR.ui.dialog.labeledElement
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a labeledElement class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Required) The label string.
			 * * `labelLayout` (Optional) Put &#39;horizontal&#39; here if the
			 *     label element is to be laid out horizontally. Otherwise a vertical
			 *     layout will be used.
			 * * `widths` (Optional) This applies only to horizontal
			 *     layouts &amp;mdash; a two-element array of lengths to specify the widths of the
			 *     label and the content element.
			 * * `role` (Optional) Value for the `role` attribute.
			 * * `includeLabel` (Optional) If set to `true`, the `aria-labelledby` attribute
			 *     will be included.
			 *
			 * @param {Array} htmlList The list of HTML code to output to.
			 * @param {Function} contentHtml
			 * A function returning the HTML code string to be added inside the content
			 * cell.
			 */
			labeledElement: function( dialog, elementDefinition, htmlList, contentHtml ) {
				if ( arguments.length &lt; 4 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition );
				_.labelId = CKEDITOR.tools.getNextId() + &#39;_label&#39;;
				this._.children = [];

				var innerHTML = function() {
						var html = [],
							requiredClass = elementDefinition.required ? &#39; cke_required&#39; : &#39;&#39;;
						if ( elementDefinition.labelLayout != &#39;horizontal&#39; ) {
							html.push(
								&#39;&lt;label class=&quot;cke_dialog_ui_labeled_label&#39; + requiredClass + &#39;&quot; &#39;, &#39; id=&quot;&#39; + _.labelId + &#39;&quot;&#39;,
									( _.inputId ? &#39; for=&quot;&#39; + _.inputId + &#39;&quot;&#39; : &#39;&#39; ),
									( elementDefinition.labelStyle ? &#39; style=&quot;&#39; + elementDefinition.labelStyle + &#39;&quot;&#39; : &#39;&#39; ) + &#39;&gt;&#39;,
									elementDefinition.label,
								&#39;&lt;/label&gt;&#39;,
								&#39;&lt;div class=&quot;cke_dialog_ui_labeled_content&quot;&#39;,
									( elementDefinition.controlStyle ? &#39; style=&quot;&#39; + elementDefinition.controlStyle + &#39;&quot;&#39; : &#39;&#39; ),
									&#39; role=&quot;presentation&quot;&gt;&#39;,
									contentHtml.call( this, dialog, elementDefinition ),
								&#39;&lt;/div&gt;&#39; );
						} else {
							var hboxDefinition = {
								type: &#39;hbox&#39;,
								widths: elementDefinition.widths,
								padding: 0,
								children: [ {
									type: &#39;html&#39;,
									html: &#39;&lt;label class=&quot;cke_dialog_ui_labeled_label&#39; + requiredClass + &#39;&quot;&#39; +
										&#39; id=&quot;&#39; + _.labelId + &#39;&quot;&#39; +
										&#39; for=&quot;&#39; + _.inputId + &#39;&quot;&#39; +
										( elementDefinition.labelStyle ? &#39; style=&quot;&#39; + elementDefinition.labelStyle + &#39;&quot;&#39; : &#39;&#39; ) + &#39;&gt;&#39; +
											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +
										&#39;&lt;/label&gt;&#39;
								},
								{
									type: &#39;html&#39;,
									html: &#39;&lt;span class=&quot;cke_dialog_ui_labeled_content&quot;&#39; + ( elementDefinition.controlStyle ? &#39; style=&quot;&#39; + elementDefinition.controlStyle + &#39;&quot;&#39; : &#39;&#39; ) + &#39;&gt;&#39; +
										contentHtml.call( this, dialog, elementDefinition ) +
										&#39;&lt;/span&gt;&#39;
								} ]
							};
							CKEDITOR.dialog._.uiElementBuilders.hbox.build( dialog, hboxDefinition, html );
						}
						return html.join( &#39;&#39; );
					};
				var attributes = { role: elementDefinition.role || &#39;presentation&#39; };

				if ( elementDefinition.includeLabel )
					attributes[ &#39;aria-labelledby&#39; ] = _.labelId;

				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, &#39;div&#39;, null, attributes, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-textInput-method-constructor'><span id='CKEDITOR-ui-dialog-textInput'>			/**
</span></span>			 * A text input with a label. This UI element class represents both the
			 * single-line text inputs and password inputs in dialog boxes.
			 *
			 * @class CKEDITOR.ui.dialog.textInput
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a textInput class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Optional) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `maxLength` (Optional) The maximum length of text box contents.
			 * * `size` (Optional) The size of the text box. This is
			 *     usually overridden by the size defined by the skin, though.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			textInput: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				initPrivateObject.call( this, elementDefinition );
				var domId = this._.inputId = CKEDITOR.tools.getNextId() + &#39;_textInput&#39;,
					attributes = { &#39;class&#39;: &#39;cke_dialog_ui_input_&#39; + elementDefinition.type, id: domId, type: elementDefinition.type };

				// Set the validator, if any.
				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				// Set the max length and size.
				if ( elementDefinition.maxLength )
					attributes.maxlength = elementDefinition.maxLength;
				if ( elementDefinition.size )
					attributes.size = elementDefinition.size;

				if ( elementDefinition.inputStyle )
					attributes.style = elementDefinition.inputStyle;

				// If user presses Enter in a text box, it implies clicking OK for the dialog.
				var me = this,
					keyPressedOnMe = false;
				dialog.on( &#39;load&#39;, function() {
					me.getInputElement().on( &#39;keydown&#39;, function( evt ) {
						if ( evt.data.getKeystroke() == 13 )
							keyPressedOnMe = true;
					} );

					// Lower the priority this &#39;keyup&#39; since &#39;ok&#39; will close the dialog.(#3749)
					me.getInputElement().on( &#39;keyup&#39;, function( evt ) {
						if ( evt.data.getKeystroke() == 13 &amp;&amp; keyPressedOnMe ) {
							dialog.getButton( &#39;ok&#39; ) &amp;&amp; setTimeout( function() {
								dialog.getButton( &#39;ok&#39; ).click();
							}, 0 );
							keyPressedOnMe = false;
						}

						if ( me.bidi )
							toggleBidiKeyUpHandler.call( me, evt );
					}, null, null, 1000 );
				} );

				var innerHTML = function() {
						// IE BUG: Text input fields in IE at 100% would exceed a &lt;td&gt; or inline
						// container&#39;s width, so need to wrap it inside a &lt;div&gt;.
						var html = [ &#39;&lt;div class=&quot;cke_dialog_ui_input_&#39;, elementDefinition.type, &#39;&quot; role=&quot;presentation&quot;&#39; ];

						if ( elementDefinition.width )
							html.push( &#39;style=&quot;width:&#39; + elementDefinition.width + &#39;&quot; &#39; );

						html.push( &#39;&gt;&lt;input &#39; );

						attributes[ &#39;aria-labelledby&#39; ] = this._.labelId;
						this._.required &amp;&amp; ( attributes[ &#39;aria-required&#39; ] = this._.required );
						for ( var i in attributes )
							html.push( i + &#39;=&quot;&#39; + attributes[ i ] + &#39;&quot; &#39; );
						html.push( &#39; /&gt;&lt;/div&gt;&#39; );
						return html.join( &#39;&#39; );
					};
				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-textarea-method-constructor'><span id='CKEDITOR-ui-dialog-textarea'>			/**
</span></span>			 * A text area with a label at the top or on the left.
			 *
			 * @class CKEDITOR.ui.dialog.textarea
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a textarea class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 *
			 * The element definition. Accepted fields:
			 *
			 * * `rows` (Optional) The number of rows displayed.
			 *     Defaults to 5 if not defined.
			 * * `cols` (Optional) The number of cols displayed.
			 *     Defaults to 20 if not defined. Usually overridden by skins.
			 * * `default` (Optional) The default value.
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			textarea: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				initPrivateObject.call( this, elementDefinition );
				var me = this,
					domId = this._.inputId = CKEDITOR.tools.getNextId() + &#39;_textarea&#39;,
					attributes = {};

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				// Generates the essential attributes for the textarea tag.
				attributes.rows = elementDefinition.rows || 5;
				attributes.cols = elementDefinition.cols || 20;

				attributes[ &#39;class&#39; ] = &#39;cke_dialog_ui_input_textarea &#39; + ( elementDefinition[ &#39;class&#39; ] || &#39;&#39; );

				if ( typeof elementDefinition.inputStyle != &#39;undefined&#39; )
					attributes.style = elementDefinition.inputStyle;

				if ( elementDefinition.dir )
					attributes.dir = elementDefinition.dir;

				if ( me.bidi ) {
					dialog.on( &#39;load&#39;, function() {
						me.getInputElement().on( &#39;keyup&#39;, toggleBidiKeyUpHandler );
					}, me );
				}

				var innerHTML = function() {
						attributes[ &#39;aria-labelledby&#39; ] = this._.labelId;
						this._.required &amp;&amp; ( attributes[ &#39;aria-required&#39; ] = this._.required );
						var html = [ &#39;&lt;div class=&quot;cke_dialog_ui_input_textarea&quot; role=&quot;presentation&quot;&gt;&lt;textarea id=&quot;&#39;, domId, &#39;&quot; &#39; ];
						for ( var i in attributes )
							html.push( i + &#39;=&quot;&#39; + CKEDITOR.tools.htmlEncode( attributes[ i ] ) + &#39;&quot; &#39; );
						html.push( &#39;&gt;&#39;, CKEDITOR.tools.htmlEncode( me._[ &#39;default&#39; ] ), &#39;&lt;/textarea&gt;&lt;/div&gt;&#39; );
						return html.join( &#39;&#39; );
					};
				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-checkbox-method-constructor'><span id='CKEDITOR-ui-dialog-checkbox'>			/**
</span></span>			 * A single checkbox with a label on the right.
			 *
			 * @class CKEDITOR.ui.dialog.checkbox
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a checkbox class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `checked` (Optional) Whether the checkbox is checked
			 *     on instantiation. Defaults to `false`.
			 * * `validate` (Optional) The validation function.
			 * * `label` (Optional) The checkbox label.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			checkbox: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition, { &#39;default&#39;: !!elementDefinition[ &#39;default&#39; ] } );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				var innerHTML = function() {
						var myDefinition = CKEDITOR.tools.extend(
								{},
								elementDefinition,
								{
									id: elementDefinition.id ? elementDefinition.id + &#39;_checkbox&#39; : CKEDITOR.tools.getNextId() + &#39;_checkbox&#39;
								},
								true
							),
							html = [];

						var labelId = CKEDITOR.tools.getNextId() + &#39;_label&#39;;
						var attributes = { &#39;class&#39;: &#39;cke_dialog_ui_checkbox_input&#39;, type: &#39;checkbox&#39;, &#39;aria-labelledby&#39;: labelId };
						cleanInnerDefinition( myDefinition );
						if ( elementDefinition[ &#39;default&#39; ] )
							attributes.checked = &#39;checked&#39;;

						if ( typeof myDefinition.inputStyle != &#39;undefined&#39; )
							myDefinition.style = myDefinition.inputStyle;

						_.checkbox = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, &#39;input&#39;, null, attributes );
						html.push(
							&#39; &lt;label id=&quot;&#39;,
							labelId,
							&#39;&quot; for=&quot;&#39;,
							attributes.id,
							&#39;&quot;&#39; + ( elementDefinition.labelStyle ? &#39; style=&quot;&#39; + elementDefinition.labelStyle + &#39;&quot;&#39; : &#39;&#39; ) + &#39;&gt;&#39;,
							CKEDITOR.tools.htmlEncode( elementDefinition.label ),
							&#39;&lt;/label&gt;&#39;
						);
						return html.join( &#39;&#39; );
					};

				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, &#39;span&#39;, null, null, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-radio-method-constructor'><span id='CKEDITOR-ui-dialog-radio'>			/**
</span></span>			 * A group of radio buttons.
			 *
			 * @class CKEDITOR.ui.dialog.radio
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a radio class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Required) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `items` (Required) An array of options. Each option
			 *     is a one- or two-item array of format `[ &#39;Description&#39;, &#39;Value&#39; ]`. If `&#39;Value&#39;`
			 *     is missing, then the value would be assumed to be the same as the description.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			radio: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				initPrivateObject.call( this, elementDefinition );

				if ( !this._[ &#39;default&#39; ] )
					this._[ &#39;default&#39; ] = this._.initValue = elementDefinition.items[ 0 ][ 1 ];

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				var children = [],
					me = this;

				var innerHTML = function() {
					var inputHtmlList = [],
						html = [],
						commonName = ( elementDefinition.id ? elementDefinition.id : CKEDITOR.tools.getNextId() ) + &#39;_radio&#39;;

					for ( var i = 0; i &lt; elementDefinition.items.length; i++ ) {
						var item = elementDefinition.items[ i ],
							title = item[ 2 ] !== undefined ? item[ 2 ] : item[ 0 ],
							value = item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ],
							inputId = CKEDITOR.tools.getNextId() + &#39;_radio_input&#39;,
							labelId = inputId + &#39;_label&#39;,

							inputDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {
								id: inputId,
								title: null,
								type: null
							}, true ),

							labelDefinition = CKEDITOR.tools.extend( {}, inputDefinition, {
								title: title
							}, true ),

							inputAttributes = {
								type: &#39;radio&#39;,
								&#39;class&#39;: &#39;cke_dialog_ui_radio_input&#39;,
								name: commonName,
								value: value,
								&#39;aria-labelledby&#39;: labelId
							},

							inputHtml = [];

						if ( me._[ &#39;default&#39; ] == value )
							inputAttributes.checked = &#39;checked&#39;;

						cleanInnerDefinition( inputDefinition );
						cleanInnerDefinition( labelDefinition );

						if ( typeof inputDefinition.inputStyle != &#39;undefined&#39; )
							inputDefinition.style = inputDefinition.inputStyle;

						// Make inputs of radio type focusable (#10866).
						inputDefinition.keyboardFocusable = true;

						children.push( new CKEDITOR.ui.dialog.uiElement( dialog, inputDefinition, inputHtml, &#39;input&#39;, null, inputAttributes ) );

						inputHtml.push( &#39; &#39; );

						new CKEDITOR.ui.dialog.uiElement( dialog, labelDefinition, inputHtml, &#39;label&#39;, null, {
							id: labelId,
							&#39;for&#39;: inputAttributes.id
						}, item[ 0 ] );

						inputHtmlList.push( inputHtml.join( &#39;&#39; ) );
					}

					new CKEDITOR.ui.dialog.hbox( dialog, children, inputHtmlList, html );

					return html.join( &#39;&#39; );
				};

				// Adding a role=&quot;radiogroup&quot; to definition used for wrapper.
				elementDefinition.role = &#39;radiogroup&#39;;
				elementDefinition.includeLabel = true;

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
				this._.children = children;
			},

<span id='CKEDITOR-ui-dialog-button-method-constructor'><span id='CKEDITOR-ui-dialog-button'>			/**
</span></span>			 * A button with a label inside.
			 *
			 * @class CKEDITOR.ui.dialog.button
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a button class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Required) The button label.
			 * * `disabled` (Optional) Set to `true` if you want the
			 *     button to appear in the disabled state.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			button: function( dialog, elementDefinition, htmlList ) {
				if ( !arguments.length )
					return;

				if ( typeof elementDefinition == &#39;function&#39; )
					elementDefinition = elementDefinition( dialog.getParentEditor() );

				initPrivateObject.call( this, elementDefinition, { disabled: elementDefinition.disabled || false } );

				// Add OnClick event to this input.
				CKEDITOR.event.implementOn( this );

				var me = this;

				// Register an event handler for processing button clicks.
				dialog.on( &#39;load&#39;, function() {
					var element = this.getElement();

					( function() {
						element.on( &#39;click&#39;, function( evt ) {
							me.click();
							// #9958
							evt.data.preventDefault();
						} );

						element.on( &#39;keydown&#39;, function( evt ) {
							if ( evt.data.getKeystroke() in { 32: 1 } ) {
								me.click();
								evt.data.preventDefault();
							}
						} );
					} )();

					element.unselectable();
				}, this );

				var outerDefinition = CKEDITOR.tools.extend( {}, elementDefinition );
				delete outerDefinition.style;

				var labelId = CKEDITOR.tools.getNextId() + &#39;_label&#39;;
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, outerDefinition, htmlList, &#39;a&#39;, null, {
					style: elementDefinition.style,
					href: &#39;javascript:void(0)&#39;, // jshint ignore:line
					title: elementDefinition.label,
					hidefocus: &#39;true&#39;,
					&#39;class&#39;: elementDefinition[ &#39;class&#39; ],
					role: &#39;button&#39;,
					&#39;aria-labelledby&#39;: labelId
				}, &#39;&lt;span id=&quot;&#39; + labelId + &#39;&quot; class=&quot;cke_dialog_ui_button&quot;&gt;&#39; +
											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +
										&#39;&lt;/span&gt;&#39; );
			},

<span id='CKEDITOR-ui-dialog-select-method-constructor'><span id='CKEDITOR-ui-dialog-select'>			/**
</span></span>			 * A select box.
			 *
			 * @class CKEDITOR.ui.dialog.select
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a button class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `default` (Required) The default value.
			 * * `validate` (Optional) The validation function.
			 * * `items` (Required) An array of options. Each option
			 *     is a one- or two-item array of format `[ &#39;Description&#39;, &#39;Value&#39; ]`. If `&#39;Value&#39;`
			 *     is missing, then the value would be assumed to be the same as the
			 *     description.
			 * * `multiple` (Optional) Set this to `true` if you would like
			 *     to have a multiple-choice select box.
			 * * `size` (Optional) The number of items to display in
			 *     the select box.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			select: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				var _ = initPrivateObject.call( this, elementDefinition );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				_.inputId = CKEDITOR.tools.getNextId() + &#39;_select&#39;;

				var innerHTML = function() {
						var myDefinition = CKEDITOR.tools.extend(
								{},
								elementDefinition,
								{
									id: ( elementDefinition.id ? elementDefinition.id + &#39;_select&#39; : CKEDITOR.tools.getNextId() + &#39;_select&#39; )
								},
								true
							),
							html = [],
							innerHTML = [],
							attributes = { &#39;id&#39;: _.inputId, &#39;class&#39;: &#39;cke_dialog_ui_input_select&#39;, &#39;aria-labelledby&#39;: this._.labelId };

						html.push( &#39;&lt;div class=&quot;cke_dialog_ui_input_&#39;, elementDefinition.type, &#39;&quot; role=&quot;presentation&quot;&#39; );
						if ( elementDefinition.width )
							html.push( &#39;style=&quot;width:&#39; + elementDefinition.width + &#39;&quot; &#39; );
						html.push( &#39;&gt;&#39; );

						// Add multiple and size attributes from element definition.
						if ( elementDefinition.size !== undefined )
							attributes.size = elementDefinition.size;
						if ( elementDefinition.multiple !== undefined )
							attributes.multiple = elementDefinition.multiple;

						cleanInnerDefinition( myDefinition );
						for ( var i = 0, item; i &lt; elementDefinition.items.length &amp;&amp; ( item = elementDefinition.items[ i ] ); i++ ) {
							innerHTML.push( &#39;&lt;option value=&quot;&#39;, CKEDITOR.tools.htmlEncode( item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ] ).replace( /&quot;/g, &#39;&amp;quot;&#39; ), &#39;&quot; /&gt; &#39;, CKEDITOR.tools.htmlEncode( item[ 0 ] ) );
						}

						if ( typeof myDefinition.inputStyle != &#39;undefined&#39; )
							myDefinition.style = myDefinition.inputStyle;

						_.select = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, &#39;select&#39;, null, attributes, innerHTML.join( &#39;&#39; ) );

						html.push( &#39;&lt;/div&gt;&#39; );

						return html.join( &#39;&#39; );
					};

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-file-method-constructor'><span id='CKEDITOR-ui-dialog-file'>			/**
</span></span>			 * A file upload input.
			 *
			 * @class CKEDITOR.ui.dialog.file
			 * @extends CKEDITOR.ui.dialog.labeledElement
			 * @constructor Creates a file class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			file: function( dialog, elementDefinition, htmlList ) {
				if ( arguments.length &lt; 3 )
					return;

				if ( elementDefinition[ &#39;default&#39; ] === undefined )
					elementDefinition[ &#39;default&#39; ] = &#39;&#39;;

				var _ = CKEDITOR.tools.extend( initPrivateObject.call( this, elementDefinition ), { definition: elementDefinition, buttons: [] } );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

<span id='global-method-innerHTML'>				/** @ignore */
</span>				var innerHTML = function() {
					_.frameId = CKEDITOR.tools.getNextId() + &#39;_fileInput&#39;;

					var html = [
						&#39;&lt;iframe&#39; +
							&#39; frameborder=&quot;0&quot;&#39; +
							&#39; allowtransparency=&quot;0&quot;&#39; +
							&#39; class=&quot;cke_dialog_ui_input_file&quot;&#39; +
							&#39; role=&quot;presentation&quot;&#39; +
							&#39; id=&quot;&#39;, _.frameId, &#39;&quot;&#39; +
							&#39; title=&quot;&#39;, elementDefinition.label, &#39;&quot;&#39; +
							&#39; src=&quot;javascript:void(&#39;
					];

					// Support for custom document.domain on IE. (#10165)
					html.push( CKEDITOR.env.ie ?
						&#39;(function(){&#39; + encodeURIComponent(
							&#39;document.open();&#39; +
							&#39;(&#39; + CKEDITOR.tools.fixDomain + &#39;)();&#39; +
							&#39;document.close();&#39;
						) + &#39;})()&#39;
						:
						&#39;0&#39;
					);

					html.push( &#39;)&quot;&gt;&lt;/iframe&gt;&#39; );

					return html.join( &#39;&#39; );
				};

				// IE BUG: Parent container does not resize to contain the iframe automatically.
				dialog.on( &#39;load&#39;, function() {
					var iframe = CKEDITOR.document.getById( _.frameId ),
						contentDiv = iframe.getParent();
					contentDiv.addClass( &#39;cke_dialog_ui_input_file&#39; );
				} );

				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );
			},

<span id='CKEDITOR-ui-dialog-fileButton-method-constructor'><span id='CKEDITOR-ui-dialog-fileButton'>			/**
</span></span>			 * A button for submitting the file in a file upload input.
			 *
			 * @class CKEDITOR.ui.dialog.fileButton
			 * @extends CKEDITOR.ui.dialog.button
			 * @constructor Creates a fileButton class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `for` (Required) The file input&#39;s page and element ID
			 *     to associate with, in a two-item array format: `[ &#39;page_id&#39;, &#39;element_id&#39; ]`.
			 * * `validate` (Optional) The validation function.
			 *
			 * @param {Array} htmlList List of HTML code to output to.
			 */
			fileButton: function( dialog, elementDefinition, htmlList ) {
				var me = this;
				if ( arguments.length &lt; 3 )
					return;

				initPrivateObject.call( this, elementDefinition );

				if ( elementDefinition.validate )
					this.validate = elementDefinition.validate;

				var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition );
				var onClick = myDefinition.onClick;
				myDefinition.className = ( myDefinition.className ? myDefinition.className + &#39; &#39; : &#39;&#39; ) + &#39;cke_dialog_ui_button&#39;;
				myDefinition.onClick = function( evt ) {
					var target = elementDefinition[ &#39;for&#39; ]; // [ pageId, elementId ]
					if ( !onClick || onClick.call( this, evt ) !== false ) {
						dialog.getContentElement( target[ 0 ], target[ 1 ] ).submit();
						this.disable();
					}
				};

				dialog.on( &#39;load&#39;, function() {
					dialog.getContentElement( elementDefinition[ &#39;for&#39; ][ 0 ], elementDefinition[ &#39;for&#39; ][ 1 ] )._.buttons.push( me );
				} );

				CKEDITOR.ui.dialog.button.call( this, dialog, myDefinition, htmlList );
			},

			html: ( function() {
				var myHtmlRe = /^\s*&lt;[\w:]+\s+([^&gt;]*)?&gt;/,
					theirHtmlRe = /^(\s*&lt;[\w:]+(?:\s+[^&gt;]*)?)((?:.|\r|\n)+)$/,
					emptyTagRe = /\/$/;
<span id='CKEDITOR-ui-dialog-html-method-constructor'><span id='CKEDITOR-ui-dialog-html'>				/**
</span></span>				 * A dialog window element made from raw HTML code.
				 *
				 * @class CKEDITOR.ui.dialog.html
				 * @extends CKEDITOR.ui.dialog.uiElement
				 * @constructor Creates a html class instance.
				 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
				 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition Element definition.
				 * Accepted fields:
				 *
				 * * `html` (Required) HTML code of this element.
				 *
				 * @param {Array} htmlList List of HTML code to be added to the dialog&#39;s content area.
				 */
				return function( dialog, elementDefinition, htmlList ) {
					if ( arguments.length &lt; 3 )
						return;

					var myHtmlList = [],
						myHtml,
						theirHtml = elementDefinition.html,
						myMatch, theirMatch;

					// If the HTML input doesn&#39;t contain any tags at the beginning, add a &lt;span&gt; tag around it.
					if ( theirHtml.charAt( 0 ) != &#39;&lt;&#39; )
						theirHtml = &#39;&lt;span&gt;&#39; + theirHtml + &#39;&lt;/span&gt;&#39;;

					// Look for focus function in definition.
					var focus = elementDefinition.focus;
					if ( focus ) {
						var oldFocus = this.focus;
						this.focus = function() {
							( typeof focus == &#39;function&#39; ? focus : oldFocus ).call( this );
							this.fire( &#39;focus&#39; );
						};
						if ( elementDefinition.isFocusable ) {
							var oldIsFocusable = this.isFocusable;
							this.isFocusable = oldIsFocusable;
						}
						this.keyboardFocusable = true;
					}

					CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, myHtmlList, &#39;span&#39;, null, null, &#39;&#39; );

					// Append the attributes created by the uiElement call to the real HTML.
					myHtml = myHtmlList.join( &#39;&#39; );
					myMatch = myHtml.match( myHtmlRe );
					theirMatch = theirHtml.match( theirHtmlRe ) || [ &#39;&#39;, &#39;&#39;, &#39;&#39; ];

					if ( emptyTagRe.test( theirMatch[ 1 ] ) ) {
						theirMatch[ 1 ] = theirMatch[ 1 ].slice( 0, -1 );
						theirMatch[ 2 ] = &#39;/&#39; + theirMatch[ 2 ];
					}

					htmlList.push( [ theirMatch[ 1 ], &#39; &#39;, myMatch[ 1 ] || &#39;&#39;, theirMatch[ 2 ] ].join( &#39;&#39; ) );
				};
			} )(),

<span id='CKEDITOR-ui-dialog-fieldset-method-constructor'><span id='CKEDITOR-ui-dialog-fieldset'>			/**
</span></span>			 * Form fieldset for grouping dialog UI elements.
			 *
			 * @class CKEDITOR.ui.dialog.fieldset
			 * @extends CKEDITOR.ui.dialog.uiElement
			 * @constructor Creates a fieldset class instance.
			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.
			 * @param {Array} childObjList
			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.
			 * @param {Array} childHtmlList Array of HTML code that corresponds to the HTML output of all the
			 * objects in childObjList.
			 * @param {Array} htmlList Array of HTML code that this element will output to.
			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition
			 * The element definition. Accepted fields:
			 *
			 * * `label` (Optional) The legend of the this fieldset.
			 * * `children` (Required) An array of dialog window field definitions which will be grouped inside this fieldset.
			 *
			 */
			fieldset: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {
				var legendLabel = elementDefinition.label;
<span id='global-method-innerHTML'>				/** @ignore */
</span>				var innerHTML = function() {
						var html = [];
						legendLabel &amp;&amp; html.push( &#39;&lt;legend&#39; +
							( elementDefinition.labelStyle ? &#39; style=&quot;&#39; + elementDefinition.labelStyle + &#39;&quot;&#39; : &#39;&#39; ) +
							&#39;&gt;&#39; + legendLabel + &#39;&lt;/legend&gt;&#39; );
						for ( var i = 0; i &lt; childHtmlList.length; i++ )
							html.push( childHtmlList[ i ] );
						return html.join( &#39;&#39; );
					};

				this._ = { children: childObjList };
				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, &#39;fieldset&#39;, null, null, innerHTML );
			}

		}, true );

		CKEDITOR.ui.dialog.html.prototype = new CKEDITOR.ui.dialog.uiElement();

<span id='CKEDITOR-ui-dialog-labeledElement'>		/** @class CKEDITOR.ui.dialog.labeledElement */
</span>		CKEDITOR.ui.dialog.labeledElement.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement(), {
<span id='CKEDITOR-ui-dialog-labeledElement-method-setLabel'>			/**
</span>			 * Sets the label text of the element.
			 *
			 * @param {String} label The new label text.
			 * @returns {CKEDITOR.ui.dialog.labeledElement} The current labeled element.
			 */
			setLabel: function( label ) {
				var node = CKEDITOR.document.getById( this._.labelId );
				if ( node.getChildCount() &lt; 1 )
				( new CKEDITOR.dom.text( label, CKEDITOR.document ) ).appendTo( node );
				else
					node.getChild( 0 ).$.nodeValue = label;
				return this;
			},

<span id='CKEDITOR-ui-dialog-labeledElement-method-getLabel'>			/**
</span>			 * Retrieves the current label text of the elment.
			 *
			 * @returns {String} The current label text.
			 */
			getLabel: function() {
				var node = CKEDITOR.document.getById( this._.labelId );
				if ( !node || node.getChildCount() &lt; 1 )
					return &#39;&#39;;
				else
					return node.getChild( 0 ).getText();
			},

<span id='CKEDITOR-ui-dialog-labeledElement-property-eventProcessors'>			/**
</span>			 * Defines the `onChange` event for UI element definitions.
			 * @property {Object}
			 */
			eventProcessors: commonEventProcessors
		}, true );

<span id='CKEDITOR-ui-dialog-button'>		/** @class CKEDITOR.ui.dialog.button */
</span>		CKEDITOR.ui.dialog.button.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement(), {
<span id='CKEDITOR-ui-dialog-button-method-click'>			/**
</span>			 * Simulates a click to the button.
			 *
			 * @returns {Object} Return value of the `click` event.
			 */
			click: function() {
				if ( !this._.disabled )
					return this.fire( &#39;click&#39;, { dialog: this._.dialog } );
				return false;
			},

<span id='CKEDITOR-ui-dialog-button-method-enable'>			/**
</span>			 * Enables the button.
			 */
			enable: function() {
				this._.disabled = false;
				var element = this.getElement();
				element &amp;&amp; element.removeClass( &#39;cke_disabled&#39; );
			},

<span id='CKEDITOR-ui-dialog-button-method-disable'>			/**
</span>			 * Disables the button.
			 */
			disable: function() {
				this._.disabled = true;
				this.getElement().addClass( &#39;cke_disabled&#39; );
			},

<span id='CKEDITOR-ui-dialog-button-method-isVisible'>			/**
</span>			 * Checks whether a field is visible.
			 *
			 * @returns {Boolean}
			 */
			isVisible: function() {
				return this.getElement().getFirst().isVisible();
			},

<span id='CKEDITOR-ui-dialog-button-method-isEnabled'>			/**
</span>			 * Checks whether a field is enabled. Fields can be disabled by using the
			 * {@link #disable} method and enabled by using the {@link #enable} method.
			 *
			 * @returns {Boolean}
			 */
			isEnabled: function() {
				return !this._.disabled;
			},

<span id='CKEDITOR-ui-dialog-button-property-eventProcessors'>			/**
</span>			 * Defines the `onChange` event and `onClick` for button element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {
				onClick: function( dialog, func ) {
					this.on( &#39;click&#39;, function() {
						func.apply( this, arguments );
					} );
				}
			}, true ),

<span id='CKEDITOR-ui-dialog-button-method-accessKeyUp'>			/**
</span>			 * Handler for the element&#39;s access key up event. Simulates a click to
			 * the button.
			 */
			accessKeyUp: function() {
				this.click();
			},

<span id='CKEDITOR-ui-dialog-button-method-accessKeyDown'>			/**
</span>			 * Handler for the element&#39;s access key down event. Simulates a mouse
			 * down to the button.
			 */
			accessKeyDown: function() {
				this.focus();
			},

			keyboardFocusable: true
		}, true );

<span id='CKEDITOR-ui-dialog-textInput'>		/** @class CKEDITOR.ui.dialog.textInput */
</span>		CKEDITOR.ui.dialog.textInput.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement(), {
<span id='CKEDITOR-ui-dialog-textInput-method-getInputElement'>			/**
</span>			 * Gets the text input DOM element under this UI object.
			 *
			 * @returns {CKEDITOR.dom.element} The DOM element of the text input.
			 */
			getInputElement: function() {
				return CKEDITOR.document.getById( this._.inputId );
			},

<span id='CKEDITOR-ui-dialog-textInput-method-focus'>			/**
</span>			 * Puts focus into the text input.
			 */
			focus: function() {
				var me = this.selectParentTab();

				// GECKO BUG: setTimeout() is needed to workaround invisible selections.
				setTimeout( function() {
					var element = me.getInputElement();
					element &amp;&amp; element.$.focus();
				}, 0 );
			},

<span id='CKEDITOR-ui-dialog-textInput-method-select'>			/**
</span>			 * Selects all the text in the text input.
			 */
			select: function() {
				var me = this.selectParentTab();

				// GECKO BUG: setTimeout() is needed to workaround invisible selections.
				setTimeout( function() {
					var e = me.getInputElement();
					if ( e ) {
						e.$.focus();
						e.$.select();
					}
				}, 0 );
			},

<span id='CKEDITOR-ui-dialog-textInput-method-accessKeyUp'>			/**
</span>			 * Handler for the text input&#39;s access key up event. Makes a `select()`
			 * call to the text input.
			 */
			accessKeyUp: function() {
				this.select();
			},

<span id='CKEDITOR-ui-dialog-textInput-method-setValue'>			/**
</span>			 * Sets the value of this text input object.
			 *
			 *		uiElement.setValue( &#39;Blamo&#39; );
			 *
			 * @param {Object} value The new value.
			 * @returns {CKEDITOR.ui.dialog.textInput} The current UI element.
			 */
			setValue: function( value ) {
				if ( this.bidi ) {
					var marker = value &amp;&amp; value.charAt( 0 ),
						dir = ( marker == &#39;\u202A&#39; ? &#39;ltr&#39; : marker == &#39;\u202B&#39; ? &#39;rtl&#39; : null );

					if ( dir ) {
						value = value.slice( 1 );
					}

					// Set the marker or reset it (if dir==null).
					this.setDirectionMarker( dir );
				}

				if ( !value ) {
					value = &#39;&#39;;
				}

				return CKEDITOR.ui.dialog.uiElement.prototype.setValue.apply( this, arguments );
			},

<span id='CKEDITOR-ui-dialog-textInput-method-getValue'>			/**
</span>			 * Gets the value of this text input object.
			 *
			 * @returns {String} The value.
			 */
			getValue: function() {
				var value = CKEDITOR.ui.dialog.uiElement.prototype.getValue.call( this );

				if ( this.bidi &amp;&amp; value ) {
					var dir = this.getDirectionMarker();
					if ( dir ) {
						value = ( dir == &#39;ltr&#39; ? &#39;\u202A&#39; : &#39;\u202B&#39; ) + value;
					}
				}

				return value;
			},

<span id='CKEDITOR-ui-dialog-textInput-method-setDirectionMarker'>			/**
</span>			 * Sets the text direction marker and the `dir` attribute of the input element.
			 *
			 * @since 4.5
			 * @param {String} dir The text direction. Pass `null` to reset.
			 */
			setDirectionMarker: function( dir ) {
				var inputElement = this.getInputElement();

				if ( dir ) {
					inputElement.setAttributes( {
						dir: dir,
						&#39;data-cke-dir-marker&#39;: dir
					} );
				// Don&#39;t remove the dir attribute if this field hasn&#39;t got the marker,
				// because the dir attribute could be set independently.
				} else if ( this.getDirectionMarker() ) {
					inputElement.removeAttributes( [ &#39;dir&#39;, &#39;data-cke-dir-marker&#39; ] );
				}
			},

<span id='CKEDITOR-ui-dialog-textInput-method-getDirectionMarker'>			/**
</span>			 * Gets the value of the text direction marker.
			 *
			 * @since 4.5
			 * @returns {String} `&#39;ltr&#39;`, `&#39;rtl&#39;` or `null` if the marker is not set.
			 */
			getDirectionMarker: function() {
				return this.getInputElement().data( &#39;cke-dir-marker&#39; );
			},

			keyboardFocusable: true
		}, commonPrototype, true );

		CKEDITOR.ui.dialog.textarea.prototype = new CKEDITOR.ui.dialog.textInput();

<span id='CKEDITOR-ui-dialog-select'>		/** @class CKEDITOR.ui.dialog.select */
</span>		CKEDITOR.ui.dialog.select.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement(), {
<span id='CKEDITOR-ui-dialog-select-method-getInputElement'>			/**
</span>			 * Gets the DOM element of the select box.
			 *
			 * @returns {CKEDITOR.dom.element} The `&lt;select&gt;` element of this UI element.
			 */
			getInputElement: function() {
				return this._.select.getElement();
			},

<span id='CKEDITOR-ui-dialog-select-method-add'>			/**
</span>			 * Adds an option to the select box.
			 *
			 * @param {String} label Option label.
			 * @param {String} value (Optional) Option value, if not defined it will be
			 * assumed to be the same as the label.
			 * @param {Number} index (Optional) Position of the option to be inserted
			 * to. If not defined, the new option will be inserted to the end of list.
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			add: function( label, value, index ) {
				var option = new CKEDITOR.dom.element( &#39;option&#39;, this.getDialog().getParentEditor().document ),
					selectElement = this.getInputElement().$;
				option.$.text = label;
				option.$.value = ( value === undefined || value === null ) ? label : value;
				if ( index === undefined || index === null ) {
					if ( CKEDITOR.env.ie ) {
						selectElement.add( option.$ );
					} else {
						selectElement.add( option.$, null );
					}
				} else {
					selectElement.add( option.$, index );
				}
				return this;
			},

<span id='CKEDITOR-ui-dialog-select-method-remove'>			/**
</span>			 * Removes an option from the selection list.
			 *
			 * @param {Number} index Index of the option to be removed.
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			remove: function( index ) {
				var selectElement = this.getInputElement().$;
				selectElement.remove( index );
				return this;
			},

<span id='CKEDITOR-ui-dialog-select-method-clear'>			/**
</span>			 * Clears all options out of the selection list.
			 *
			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.
			 */
			clear: function() {
				var selectElement = this.getInputElement().$;
				while ( selectElement.length &gt; 0 )
					selectElement.remove( 0 );
				return this;
			},

			keyboardFocusable: true
		}, commonPrototype, true );

<span id='CKEDITOR-ui-dialog-checkbox'>		/** @class CKEDITOR.ui.dialog.checkbox */
</span>		CKEDITOR.ui.dialog.checkbox.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement(), {
<span id='CKEDITOR-ui-dialog-checkbox-method-getInputElement'>			/**
</span>			 * Gets the checkbox DOM element.
			 *
			 * @returns {CKEDITOR.dom.element} The DOM element of the checkbox.
			 */
			getInputElement: function() {
				return this._.checkbox.getElement();
			},

<span id='CKEDITOR-ui-dialog-checkbox-method-setValue'>			/**
</span>			 * Sets the state of the checkbox.
			 *
			 * @param {Boolean} checked `true` to tick the checkbox, `false` to untick it.
			 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.
			 */
			setValue: function( checked, noChangeEvent ) {
				this.getInputElement().$.checked = checked;
				!noChangeEvent &amp;&amp; this.fire( &#39;change&#39;, { value: checked } );
			},

<span id='CKEDITOR-ui-dialog-checkbox-method-getValue'>			/**
</span>			 * Gets the state of the checkbox.
			 *
			 * @returns {Boolean} `true` means that the checkbox is ticked, `false` means it is not ticked.
			 */
			getValue: function() {
				return this.getInputElement().$.checked;
			},

<span id='CKEDITOR-ui-dialog-checkbox-method-accessKeyUp'>			/**
</span>			 * Handler for the access key up event. Toggles the checkbox.
			 */
			accessKeyUp: function() {
				this.setValue( !this.getValue() );
			},

<span id='CKEDITOR-ui-dialog-checkbox-property-eventProcessors'>			/**
</span>			 * Defines the `onChange` event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					if ( !CKEDITOR.env.ie || ( CKEDITOR.env.version &gt; 8 ) )
						return commonEventProcessors.onChange.apply( this, arguments );
					else {
						dialog.on( &#39;load&#39;, function() {
							var element = this._.checkbox.getElement();
							element.on( &#39;propertychange&#39;, function( evt ) {
								evt = evt.data.$;
								if ( evt.propertyName == &#39;checked&#39; )
									this.fire( &#39;change&#39;, { value: element.$.checked } );
							}, this );
						}, this );
						this.on( &#39;change&#39;, func );
					}
					return null;
				}
			},

			keyboardFocusable: true
		}, commonPrototype, true );

<span id='CKEDITOR-ui-dialog-radio'>		/** @class CKEDITOR.ui.dialog.radio */
</span>		CKEDITOR.ui.dialog.radio.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement(), {
<span id='CKEDITOR-ui-dialog-radio-method-setValue'>			/**
</span>			 * Selects one of the radio buttons in this button group.
			 *
			 * @param {String} value The value of the button to be chcked.
			 * @param {Boolean} noChangeEvent Internal commit, to supress the `change` event on this element.
			 */
			setValue: function( value, noChangeEvent ) {
				var children = this._.children,
					item;
				for ( var i = 0;
				( i &lt; children.length ) &amp;&amp; ( item = children[ i ] ); i++ )
					item.getElement().$.checked = ( item.getValue() == value );
				!noChangeEvent &amp;&amp; this.fire( &#39;change&#39;, { value: value } );
			},

<span id='CKEDITOR-ui-dialog-radio-method-getValue'>			/**
</span>			 * Gets the value of the currently selected radio button.
			 *
			 * @returns {String} The currently selected button&#39;s value.
			 */
			getValue: function() {
				var children = this._.children;
				for ( var i = 0; i &lt; children.length; i++ ) {
					if ( children[ i ].getElement().$.checked )
						return children[ i ].getValue();
				}
				return null;
			},

<span id='CKEDITOR-ui-dialog-radio-method-accessKeyUp'>			/**
</span>			 * Handler for the access key up event. Focuses the currently
			 * selected radio button, or the first radio button if none is selected.
			 */
			accessKeyUp: function() {
				var children = this._.children,
					i;
				for ( i = 0; i &lt; children.length; i++ ) {
					if ( children[ i ].getElement().$.checked ) {
						children[ i ].getElement().focus();
						return;
					}
				}
				children[ 0 ].getElement().focus();
			},

<span id='CKEDITOR-ui-dialog-radio-property-eventProcessors'>			/**
</span>			 * Defines the `onChange` event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					if ( !CKEDITOR.env.ie || ( CKEDITOR.env.version &gt; 8 ) )
						return commonEventProcessors.onChange.apply( this, arguments );
					else {
						dialog.on( &#39;load&#39;, function() {
							var children = this._.children,
								me = this;
							for ( var i = 0; i &lt; children.length; i++ ) {
								var element = children[ i ].getElement();
								element.on( &#39;propertychange&#39;, function( evt ) {
									evt = evt.data.$;
									if ( evt.propertyName == &#39;checked&#39; &amp;&amp; this.$.checked )
										me.fire( &#39;change&#39;, { value: this.getAttribute( &#39;value&#39; ) } );
								} );
							}
						}, this );
						this.on( &#39;change&#39;, func );
					}
					return null;
				}
			}
		}, commonPrototype, true );

<span id='CKEDITOR-ui-dialog-file'>		/** @class CKEDITOR.ui.dialog.file */
</span>		CKEDITOR.ui.dialog.file.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement(), commonPrototype, {
<span id='CKEDITOR-ui-dialog-file-method-getInputElement'>			/**
</span>			 * Gets the `&lt;input&gt;` element of this file input.
			 *
			 * @returns {CKEDITOR.dom.element} The file input element.
			 */
			getInputElement: function() {
				var frameDocument = CKEDITOR.document.getById( this._.frameId ).getFrameDocument();
				return frameDocument.$.forms.length &gt; 0 ? new CKEDITOR.dom.element( frameDocument.$.forms[ 0 ].elements[ 0 ] ) : this.getElement();
			},

<span id='CKEDITOR-ui-dialog-file-method-submit'>			/**
</span>			 * Uploads the file in the file input.
			 *
			 * @returns {CKEDITOR.ui.dialog.file} This object.
			 */
			submit: function() {
				this.getInputElement().getParent().$.submit();
				return this;
			},

<span id='CKEDITOR-ui-dialog-file-method-getAction'>			/**
</span>			 * Gets the action assigned to the form.
			 *
			 * @returns {String} The value of the action.
			 */
			getAction: function() {
				return this.getInputElement().getParent().$.action;
			},

<span id='CKEDITOR-ui-dialog-file-method-registerEvents'>			/**
</span>			 * The events must be applied to the inner input element, and
			 * this must be done when the iframe and form have been loaded.
			 */
			registerEvents: function( definition ) {
				var regex = /^on([A-Z]\w+)/,
					match;

				var registerDomEvent = function( uiElement, dialog, eventName, func ) {
						uiElement.on( &#39;formLoaded&#39;, function() {
							uiElement.getInputElement().on( eventName, func, uiElement );
						} );
					};

				for ( var i in definition ) {
					if ( !( match = i.match( regex ) ) )
						continue;

					if ( this.eventProcessors[ i ] )
						this.eventProcessors[ i ].call( this, this._.dialog, definition[ i ] );
					else
						registerDomEvent( this, this._.dialog, match[ 1 ].toLowerCase(), definition[ i ] );
				}

				return this;
			},

<span id='CKEDITOR-ui-dialog-file-method-reset'>			/**
</span>			 * Redraws the file input and resets the file path in the file input.
			 * The redrawing logic is necessary because non-IE browsers tend to clear
			 * the `&lt;iframe&gt;` containing the file input after closing the dialog window.
			 */
			reset: function() {
				var _ = this._,
					frameElement = CKEDITOR.document.getById( _.frameId ),
					frameDocument = frameElement.getFrameDocument(),
					elementDefinition = _.definition,
					buttons = _.buttons,
					callNumber = this.formLoadedNumber,
					unloadNumber = this.formUnloadNumber,
					langDir = _.dialog._.editor.lang.dir,
					langCode = _.dialog._.editor.langCode;

				// The callback function for the iframe, but we must call tools.addFunction only once
				// so we store the function number in this.formLoadedNumber
				if ( !callNumber ) {
					callNumber = this.formLoadedNumber = CKEDITOR.tools.addFunction( function() {
						// Now we can apply the events to the input type=file
						this.fire( &#39;formLoaded&#39; );
					}, this );

					// Remove listeners attached to the content of the iframe (the file input)
					unloadNumber = this.formUnloadNumber = CKEDITOR.tools.addFunction( function() {
						this.getInputElement().clearCustomData();
					}, this );

					this.getDialog()._.editor.on( &#39;destroy&#39;, function() {
						CKEDITOR.tools.removeFunction( callNumber );
						CKEDITOR.tools.removeFunction( unloadNumber );
					} );
				}

				function generateFormField() {
					frameDocument.$.open();

					var size = &#39;&#39;;
					if ( elementDefinition.size )
						size = elementDefinition.size - ( CKEDITOR.env.ie ? 7 : 0 ); // &quot;Browse&quot; button is bigger in IE.

					var inputId = _.frameId + &#39;_input&#39;;

					frameDocument.$.write( [
						&#39;&lt;html dir=&quot;&#39; + langDir + &#39;&quot; lang=&quot;&#39; + langCode + &#39;&quot;&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;margin: 0; overflow: hidden; background: transparent;&quot;&gt;&#39;,
							&#39;&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot; dir=&quot;&#39; + langDir + &#39;&quot; lang=&quot;&#39; + langCode + &#39;&quot; action=&quot;&#39;,
								CKEDITOR.tools.htmlEncode( elementDefinition.action ),
							&#39;&quot;&gt;&#39;,
								// Replicate the field label inside of iframe.
								&#39;&lt;label id=&quot;&#39;, _.labelId, &#39;&quot; for=&quot;&#39;, inputId, &#39;&quot; style=&quot;display:none&quot;&gt;&#39;,
									CKEDITOR.tools.htmlEncode( elementDefinition.label ),
								&#39;&lt;/label&gt;&#39;,
								// Set width to make sure that input is not clipped by the iframe (#11253).
								&#39;&lt;input style=&quot;width:100%&quot; id=&quot;&#39;, inputId, &#39;&quot; aria-labelledby=&quot;&#39;, _.labelId, &#39;&quot; type=&quot;file&quot; name=&quot;&#39;,
									CKEDITOR.tools.htmlEncode( elementDefinition.id || &#39;cke_upload&#39; ),
									&#39;&quot; size=&quot;&#39;,
									CKEDITOR.tools.htmlEncode( size &gt; 0 ? size : &#39;&#39; ),
								&#39;&quot; /&gt;&#39;,
							&#39;&lt;/form&gt;&#39;,
						&#39;&lt;/body&gt;&lt;/html&gt;&#39;,
						&#39;&lt;script&gt;&#39;,
							// Support for custom document.domain in IE.
							CKEDITOR.env.ie ? &#39;(&#39; + CKEDITOR.tools.fixDomain + &#39;)();&#39; : &#39;&#39;,

							&#39;window.parent.CKEDITOR.tools.callFunction(&#39; + callNumber + &#39;);&#39;,
							&#39;window.onbeforeunload = function() {window.parent.CKEDITOR.tools.callFunction(&#39; + unloadNumber + &#39;)}&#39;,
						&#39;&lt;/script&gt;&#39;
					].join( &#39;&#39; ) );

					frameDocument.$.close();

					for ( var i = 0; i &lt; buttons.length; i++ )
						buttons[ i ].enable();
				}

				// #3465: Wait for the browser to finish rendering the dialog first.
				if ( CKEDITOR.env.gecko )
					setTimeout( generateFormField, 500 );
				else
					generateFormField();
			},

			getValue: function() {
				return this.getInputElement().$.value || &#39;&#39;;
			},

<span id='CKEDITOR-ui-dialog-file-method-setInitValue'>			/**
</span>			 * The default value of input `type=&quot;file&quot;` is an empty string, but during the initialization
			 * of this UI element, the iframe still is not ready so it cannot be read from that object.
			 * Setting it manually prevents later issues with the current value (`&#39;&#39;`) being different
			 * than the initial value (undefined as it asked for `.value` of a div).
			 */
			setInitValue: function() {
				this._.initValue = &#39;&#39;;
			},

<span id='CKEDITOR-ui-dialog-file-property-eventProcessors'>			/**
</span>			 * Defines the `onChange` event for UI element definitions.
			 *
			 * @property {Object}
			 */
			eventProcessors: {
				onChange: function( dialog, func ) {
					// If this method is called several times (I&#39;m not sure about how this can happen but the default
					// onChange processor includes this protection)
					// In order to reapply to the new element, the property is deleted at the beggining of the registerEvents method
					if ( !this._.domOnChangeRegistered ) {
						// By listening for the formLoaded event, this handler will get reapplied when a new
						// form is created
						this.on( &#39;formLoaded&#39;, function() {
							this.getInputElement().on( &#39;change&#39;, function() {
								this.fire( &#39;change&#39;, { value: this.getValue() } );
							}, this );
						}, this );
						this._.domOnChangeRegistered = true;
					}

					this.on( &#39;change&#39;, func );
				}
			},

			keyboardFocusable: true
		}, true );

		CKEDITOR.ui.dialog.fileButton.prototype = new CKEDITOR.ui.dialog.button();

		CKEDITOR.ui.dialog.fieldset.prototype = CKEDITOR.tools.clone( CKEDITOR.ui.dialog.hbox.prototype );

		CKEDITOR.dialog.addUIElement( &#39;text&#39;, textBuilder );
		CKEDITOR.dialog.addUIElement( &#39;password&#39;, textBuilder );
		CKEDITOR.dialog.addUIElement( &#39;textarea&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;checkbox&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;radio&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;button&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;select&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;file&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;fileButton&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;html&#39;, commonBuilder );
		CKEDITOR.dialog.addUIElement( &#39;fieldset&#39;, containerBuilder );
	}
} );

<span id='CKEDITOR-ui-dialog-uiElement-event-change'>/**
</span> * Fired when the value of the uiElement is changed.
 *
 * @event change
 * @member CKEDITOR.ui.dialog.uiElement
 */

<span id='CKEDITOR-ui-dialog-fileButton-event-formLoaded'>/**
</span> * Fired when the inner frame created by the element is ready.
 * Each time the button is used or the dialog window is loaded, a new
 * form might be created.
 *
 * @event formLoaded
 * @member CKEDITOR.ui.dialog.fileButton
 */
</pre>
</body>
</html>
