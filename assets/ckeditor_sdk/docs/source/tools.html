<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2016, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

<span id='global-property-'>/**
</span> * @fileOverview Defines the {@link CKEDITOR.tools} object that contains
 *		utility functions.
 */

( function() {
	var functions = [],
		cssVendorPrefix =
			CKEDITOR.env.gecko ? &#39;-moz-&#39; :
			CKEDITOR.env.webkit ? &#39;-webkit-&#39; :
			CKEDITOR.env.ie ? &#39;-ms-&#39; :
			&#39;&#39;,
		ampRegex = /&amp;/g,
		gtRegex = /&gt;/g,
		ltRegex = /&lt;/g,
		quoteRegex = /&quot;/g,
		tokenCharset = &#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;,
		TOKEN_COOKIE_NAME = &#39;ckCsrfToken&#39;,
		TOKEN_LENGTH = 40,

		allEscRegex = /&amp;(lt|gt|amp|quot|nbsp|shy|#\d{1,5});/g,
		namedEntities = {
			lt: &#39;&lt;&#39;,
			gt: &#39;&gt;&#39;,
			amp: &#39;&amp;&#39;,
			quot: &#39;&quot;&#39;,
			nbsp: &#39;\u00a0&#39;,
			shy: &#39;\u00ad&#39;
		},
		allEscDecode = function( match, code ) {
			if ( code[ 0 ] == &#39;#&#39; ) {
				return String.fromCharCode( parseInt( code.slice( 1 ), 10 ) );
			} else {
				return namedEntities[ code ];
			}
		};

	CKEDITOR.on( &#39;reset&#39;, function() {
		functions = [];
	} );

<span id='CKEDITOR-tools'>	/**
</span>	 * Utility functions.
	 *
	 * @class
	 * @singleton
	 */
	CKEDITOR.tools = {
<span id='CKEDITOR-tools-method-arrayCompare'>		/**
</span>		 * Compares the elements of two arrays.
		 *
		 *		var a = [ 1, &#39;a&#39;, 3 ];
		 *		var b = [ 1, 3, &#39;a&#39; ];
		 *		var c = [ 1, &#39;a&#39;, 3 ];
		 *		var d = [ 1, &#39;a&#39;, 3, 4 ];
		 *
		 *		alert( CKEDITOR.tools.arrayCompare( a, b ) );  // false
		 *		alert( CKEDITOR.tools.arrayCompare( a, c ) );  // true
		 *		alert( CKEDITOR.tools.arrayCompare( a, d ) );  // false
		 *
		 * @param {Array} arrayA An array to be compared.
		 * @param {Array} arrayB The other array to be compared.
		 * @returns {Boolean} `true` if the arrays have the same length and
		 * their elements match.
		 */
		arrayCompare: function( arrayA, arrayB ) {
			if ( !arrayA &amp;&amp; !arrayB )
				return true;

			if ( !arrayA || !arrayB || arrayA.length != arrayB.length )
				return false;

			for ( var i = 0; i &lt; arrayA.length; i++ ) {
				if ( arrayA[ i ] != arrayB[ i ] )
					return false;
			}

			return true;
		},

<span id='CKEDITOR-tools-method-getIndex'>		/**
</span>		 * Finds the index of the first element in an array for which the `compareFunction` returns `true`.
		 *
		 *		CKEDITOR.tools.getIndex( [ 1, 2, 4, 3, 5 ], function( el ) {
		 *			return el &gt;= 3;
		 *		} ); // 2
		 *
		 * @since 4.5
		 * @param {Array} array Array to search in.
		 * @param {Function} compareFunction Compare function.
		 * @returns {Number} The index of the first matching element or `-1` if none matches.
		 */
		getIndex: function( arr, compareFunction ) {
			for ( var i = 0; i &lt; arr.length; ++i ) {
				if ( compareFunction( arr[ i ] ) )
					return i;
			}
			return -1;
		},

<span id='CKEDITOR-tools-method-clone'>		/**
</span>		 * Creates a deep copy of an object.
		 *
		 * **Note**: Recursive references are not supported.
		 *
		 *		var obj = {
		 *			name: &#39;John&#39;,
		 *			cars: {
		 *				Mercedes: { color: &#39;blue&#39; },
		 *				Porsche: { color: &#39;red&#39; }
		 *			}
		 *		};
		 *		var clone = CKEDITOR.tools.clone( obj );
		 *		clone.name = &#39;Paul&#39;;
		 *		clone.cars.Porsche.color = &#39;silver&#39;;
		 *
		 *		alert( obj.name );					// &#39;John&#39;
		 *		alert( clone.name );				// &#39;Paul&#39;
		 *		alert( obj.cars.Porsche.color );	// &#39;red&#39;
		 *		alert( clone.cars.Porsche.color );	// &#39;silver&#39;
		 *
		 * @param {Object} object The object to be cloned.
		 * @returns {Object} The object clone.
		 */
		clone: function( obj ) {
			var clone;

			// Array.
			if ( obj &amp;&amp; ( obj instanceof Array ) ) {
				clone = [];

				for ( var i = 0; i &lt; obj.length; i++ )
					clone[ i ] = CKEDITOR.tools.clone( obj[ i ] );

				return clone;
			}

			// &quot;Static&quot; types.
			if ( obj === null || ( typeof obj != &#39;object&#39; ) || ( obj instanceof String ) || ( obj instanceof Number ) || ( obj instanceof Boolean ) || ( obj instanceof Date ) || ( obj instanceof RegExp ) )
				return obj;

			// DOM objects and window.
			if ( obj.nodeType || obj.window === obj )
				return obj;

			// Objects.
			clone = new obj.constructor();

			for ( var propertyName in obj ) {
				var property = obj[ propertyName ];
				clone[ propertyName ] = CKEDITOR.tools.clone( property );
			}

			return clone;
		},

<span id='CKEDITOR-tools-method-capitalize'>		/**
</span>		 * Turns the first letter of a string to upper-case.
		 *
		 * @param {String} str
		 * @param {Boolean} [keepCase] Keep the case of 2nd to last letter.
		 * @returns {String}
		 */
		capitalize: function( str, keepCase ) {
			return str.charAt( 0 ).toUpperCase() + ( keepCase ? str.slice( 1 ) : str.slice( 1 ).toLowerCase() );
		},

<span id='CKEDITOR-tools-method-extend'>		/**
</span>		 * Copies the properties from one object to another. By default, properties
		 * already present in the target object **are not** overwritten.
		 *
		 *		// Create the sample object.
		 *		var myObject = {
		 *			prop1: true
		 *		};
		 *
		 *		// Extend the above object with two properties.
		 *		CKEDITOR.tools.extend( myObject, {
		 *			prop2: true,
		 *			prop3: true
		 *		} );
		 *
		 *		// Alert &#39;prop1&#39;, &#39;prop2&#39; and &#39;prop3&#39;.
		 *		for ( var p in myObject )
		 *			alert( p );
		 *
		 * @param {Object} target The object to be extended.
		 * @param {Object...} source The object(s) from properties will be
		 * copied. Any number of objects can be passed to this function.
		 * @param {Boolean} [overwrite] If `true` is specified, it indicates that
		 * properties already present in the target object could be
		 * overwritten by subsequent objects.
		 * @param {Object} [properties] Only properties within the specified names
		 * list will be received from the source object.
		 * @returns {Object} The extended object (target).
		 */
		extend: function( target ) {
			var argsLength = arguments.length,
				overwrite, propertiesList;

			if ( typeof ( overwrite = arguments[ argsLength - 1 ] ) == &#39;boolean&#39; )
				argsLength--;
			else if ( typeof ( overwrite = arguments[ argsLength - 2 ] ) == &#39;boolean&#39; ) {
				propertiesList = arguments[ argsLength - 1 ];
				argsLength -= 2;
			}
			for ( var i = 1; i &lt; argsLength; i++ ) {
				var source = arguments[ i ];
				for ( var propertyName in source ) {
					// Only copy existed fields if in overwrite mode.
					if ( overwrite === true || target[ propertyName ] == null ) {
						// Only copy  specified fields if list is provided.
						if ( !propertiesList || ( propertyName in propertiesList ) )
							target[ propertyName ] = source[ propertyName ];

					}
				}
			}

			return target;
		},

<span id='CKEDITOR-tools-method-prototypedCopy'>		/**
</span>		 * Creates an object which is an instance of a class whose prototype is a
		 * predefined object. All properties defined in the source object are
		 * automatically inherited by the resulting object, including future
		 * changes to it.
		 *
		 * @param {Object} source The source object to be used as the prototype for
		 * the final object.
		 * @returns {Object} The resulting copy.
		 */
		prototypedCopy: function( source ) {
			var copy = function() {};
			copy.prototype = source;
			return new copy();
		},

<span id='CKEDITOR-tools-method-copy'>		/**
</span>		 * Makes fast (shallow) copy of an object.
		 * This method is faster than {@link #clone} which does
		 * a deep copy of an object (including arrays).
		 *
		 * @since 4.1
		 * @param {Object} source The object to be copied.
		 * @returns {Object} Copy of `source`.
		 */
		copy: function( source ) {
			var obj = {},
				name;

			for ( name in source )
				obj[ name ] = source[ name ];

			return obj;
		},

<span id='CKEDITOR-tools-method-isArray'>		/**
</span>		 * Checks if an object is an Array.
		 *
		 *		alert( CKEDITOR.tools.isArray( [] ) );		// true
		 *		alert( CKEDITOR.tools.isArray( &#39;Test&#39; ) );	// false
		 *
		 * @param {Object} object The object to be checked.
		 * @returns {Boolean} `true` if the object is an Array, otherwise `false`.
		 */
		isArray: function( object ) {
			return Object.prototype.toString.call( object ) == &#39;[object Array]&#39;;
		},

<span id='CKEDITOR-tools-method-isEmpty'>		/**
</span>		 * Whether the object contains no properties of its own.
		 *
		 * @param object
		 * @returns {Boolean}
		 */
		isEmpty: function( object ) {
			for ( var i in object ) {
				if ( object.hasOwnProperty( i ) )
					return false;
			}
			return true;
		},

<span id='CKEDITOR-tools-method-cssVendorPrefix'>		/**
</span>		 * Generates an object or a string containing vendor-specific and vendor-free CSS properties.
		 *
		 *		CKEDITOR.tools.cssVendorPrefix( &#39;border-radius&#39;, &#39;0&#39;, true );
		 *		// On Firefox: &#39;-moz-border-radius:0;border-radius:0&#39;
		 *		// On Chrome: &#39;-webkit-border-radius:0;border-radius:0&#39;
		 *
		 * @param {String} property The CSS property name.
		 * @param {String} value The CSS value.
		 * @param {Boolean} [asString=false] If `true`, then the returned value will be a CSS string.
		 * @returns {Object/String} The object containing CSS properties or its stringified version.
		 */
		cssVendorPrefix: function( property, value, asString ) {
			if ( asString )
				return cssVendorPrefix + property + &#39;:&#39; + value + &#39;;&#39; + property + &#39;:&#39; + value;

			var ret = {};
			ret[ property ] = value;
			ret[ cssVendorPrefix + property ] = value;

			return ret;
		},

<span id='CKEDITOR-tools-method-cssStyleToDomStyle'>		/**
</span>		 * Transforms a CSS property name to its relative DOM style name.
		 *
		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( &#39;background-color&#39; ) );	// &#39;backgroundColor&#39;
		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( &#39;float&#39; ) );				// &#39;cssFloat&#39;
		 *
		 * @method
		 * @param {String} cssName The CSS property name.
		 * @returns {String} The transformed name.
		 */
		cssStyleToDomStyle: ( function() {
			var test = document.createElement( &#39;div&#39; ).style;

			var cssFloat = ( typeof test.cssFloat != &#39;undefined&#39; ) ? &#39;cssFloat&#39; : ( typeof test.styleFloat != &#39;undefined&#39; ) ? &#39;styleFloat&#39; : &#39;float&#39;;

			return function( cssName ) {
				if ( cssName == &#39;float&#39; )
					return cssFloat;
				else {
					return cssName.replace( /-./g, function( match ) {
						return match.substr( 1 ).toUpperCase();
					} );
				}
			};
		} )(),

<span id='CKEDITOR-tools-method-buildStyleHtml'>		/**
</span>		 * Builds a HTML snippet from a set of `&lt;style&gt;/&lt;link&gt;`.
		 *
		 * @param {String/Array} css Each of which are URLs (absolute) of a CSS file or
		 * a trunk of style text.
		 * @returns {String}
		 */
		buildStyleHtml: function( css ) {
			css = [].concat( css );
			var item,
				retval = [];
			for ( var i = 0; i &lt; css.length; i++ ) {
				if ( ( item = css[ i ] ) ) {
					// Is CSS style text ?
					if ( /@import|[{}]/.test( item ) )
						retval.push( &#39;&lt;style&gt;&#39; + item + &#39;&lt;/style&gt;&#39; );
					else
						retval.push( &#39;&lt;link type=&quot;text/css&quot; rel=stylesheet href=&quot;&#39; + item + &#39;&quot;&gt;&#39; );
				}
			}
			return retval.join( &#39;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlEncode'>		/**
</span>		 * Replaces special HTML characters in a string with their relative HTML
		 * entity values.
		 *
		 *		alert( CKEDITOR.tools.htmlEncode( &#39;A &gt; B &amp; C &lt; D&#39; ) ); // &#39;A &amp;gt; B &amp;amp; C &amp;lt; D&#39;
		 *
		 * @param {String} text The string to be encoded.
		 * @returns {String} The encoded string.
		 */
		htmlEncode: function( text ) {
			// Backwards compatibility - accept also non-string values (casting is done below).
			// Since 4.4.8 we return empty string for null and undefined because these values make no sense.
			if ( text === undefined || text === null ) {
				return &#39;&#39;;
			}

			return String( text ).replace( ampRegex, &#39;&amp;amp;&#39; ).replace( gtRegex, &#39;&amp;gt;&#39; ).replace( ltRegex, &#39;&amp;lt;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlDecode'>		/**
</span>		 * Decodes HTML entities that browsers tend to encode when used in text nodes.
		 *
		 *		alert( CKEDITOR.tools.htmlDecode( &#39;&amp;lt;a &amp;amp; b &amp;gt;&#39; ) ); // &#39;&lt;a &amp; b &gt;&#39;
		 *
		 * Read more about chosen entities in the [research](http://dev.ckeditor.com/ticket/13105#comment:8).
		 *
		 * @param {String} The string to be decoded.
		 * @returns {String} The decoded string.
		 */
		htmlDecode: function( text ) {
			// See:
			// * http://dev.ckeditor.com/ticket/13105#comment:8 and comment:9,
			// * http://jsperf.com/wth-is-going-on-with-jsperf JSPerf has some serious problems, but you can observe
			// that combined regexp tends to be quicker (except on V8). It will also not be prone to fail on &#39;&amp;amp;lt;&#39;
			// (see http://dev.ckeditor.com/ticket/13105#DXWTF:CKEDITOR.tools.htmlEnDecodeAttr).
			return text.replace( allEscRegex, allEscDecode );
		},

<span id='CKEDITOR-tools-method-htmlEncodeAttr'>		/**
</span>		 * Replaces special HTML characters in HTMLElement attribute with their relative HTML entity values.
		 *
		 *		alert( CKEDITOR.tools.htmlEncodeAttr( &#39;&lt;a &quot; b &gt;&#39; ) ); // &#39;&amp;lt;a &amp;quot; b &amp;gt;&#39;
		 *
		 * @param {String} The attribute value to be encoded.
		 * @returns {String} The encoded value.
		 */
		htmlEncodeAttr: function( text ) {
			return CKEDITOR.tools.htmlEncode( text ).replace( quoteRegex, &#39;&amp;quot;&#39; );
		},

<span id='CKEDITOR-tools-method-htmlDecodeAttr'>		/**
</span>		 * Decodes HTML entities that browsers tend to encode when used in attributes.
		 *
		 *		alert( CKEDITOR.tools.htmlDecodeAttr( &#39;&amp;lt;a &amp;quot; b&amp;gt;&#39; ) ); // &#39;&lt;a &quot; b&gt;&#39;
		 *
		 * Since CKEditor 4.5 this method simply executes {@link #htmlDecode} which covers
		 * all necessary entities.
		 *
		 * @param {String} text The text to be decoded.
		 * @returns {String} The decoded text.
		 */
		htmlDecodeAttr: function( text ) {
			return CKEDITOR.tools.htmlDecode( text );
		},

<span id='CKEDITOR-tools-method-transformPlainTextToHtml'>		/**
</span>		 * Transforms text to valid HTML: creates paragraphs, replaces tabs with non-breaking spaces etc.
		 *
		 * @since 4.5
		 * @param {String} text Text to transform.
		 * @param {Number} enterMode Editor {@link CKEDITOR.config#enterMode Enter mode}.
		 * @returns {String} HTML generated from the text.
		 */
		transformPlainTextToHtml: function( text, enterMode ) {
			var isEnterBrMode = enterMode == CKEDITOR.ENTER_BR,
				// CRLF -&gt; LF
				html = this.htmlEncode( text.replace( /\r\n/g, &#39;\n&#39; ) );

			// Tab -&gt; &amp;nbsp x 4;
			html = html.replace( /\t/g, &#39;&amp;nbsp;&amp;nbsp; &amp;nbsp;&#39; );

			var paragraphTag = enterMode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39;;

			// Two line-breaks create one paragraphing block.
			if ( !isEnterBrMode ) {
				var duoLF = /\n{2}/g;
				if ( duoLF.test( html ) ) {
					var openTag = &#39;&lt;&#39; + paragraphTag + &#39;&gt;&#39;, endTag = &#39;&lt;/&#39; + paragraphTag + &#39;&gt;&#39;;
					html = openTag + html.replace( duoLF, function() {
						return endTag + openTag;
					} ) + endTag;
				}
			}

			// One &lt;br&gt; per line-break.
			html = html.replace( /\n/g, &#39;&lt;br&gt;&#39; );

			// Compensate padding &lt;br&gt; at the end of block, avoid loosing them during insertion.
			if ( !isEnterBrMode ) {
				html = html.replace( new RegExp( &#39;&lt;br&gt;(?=&lt;/&#39; + paragraphTag + &#39;&gt;)&#39; ), function( match ) {
					return CKEDITOR.tools.repeat( match, 2 );
				} );
			}

			// Preserve spaces at the ends, so they won&#39;t be lost after insertion (merged with adjacent ones).
			html = html.replace( /^ | $/g, &#39;&amp;nbsp;&#39; );

			// Finally, preserve whitespaces that are to be lost.
			html = html.replace( /(&gt;|\s) /g, function( match, before ) {
				return before + &#39;&amp;nbsp;&#39;;
			} ).replace( / (?=&lt;)/g, &#39;&amp;nbsp;&#39; );

			return html;
		},

<span id='CKEDITOR-tools-method-getNextNumber'>		/**
</span>		 * Gets a unique number for this CKEDITOR execution session. It returns
		 * consecutive numbers starting from 1.
		 *
		 *		alert( CKEDITOR.tools.getNextNumber() ); // (e.g.) 1
		 *		alert( CKEDITOR.tools.getNextNumber() ); // 2
		 *
		 * @method
		 * @returns {Number} A unique number.
		 */
		getNextNumber: ( function() {
			var last = 0;
			return function() {
				return ++last;
			};
		} )(),

<span id='CKEDITOR-tools-method-getNextId'>		/**
</span>		 * Gets a unique ID for CKEditor interface elements. It returns a
		 * string with the &quot;cke_&quot; prefix and a consecutive number.
		 *
		 *		alert( CKEDITOR.tools.getNextId() ); // (e.g.) &#39;cke_1&#39;
		 *		alert( CKEDITOR.tools.getNextId() ); // &#39;cke_2&#39;
		 *
		 * @returns {String} A unique ID.
		 */
		getNextId: function() {
			return &#39;cke_&#39; + this.getNextNumber();
		},

<span id='CKEDITOR-tools-method-getUniqueId'>		/**
</span>		 * Gets a universally unique ID. It returns a random string
		 * compliant with ISO/IEC 11578:1996, without dashes, with the &quot;e&quot; prefix to
		 * make sure that the ID does not start with a number.
		 *
		 * @returns {String} A global unique ID.
		 */
		getUniqueId: function() {
			var uuid = &#39;e&#39;; // Make sure that id does not start with number.
			for ( var i = 0; i &lt; 8; i++ ) {
				uuid += Math.floor( ( 1 + Math.random() ) * 0x10000 ).toString( 16 ).substring( 1 );
			}
			return uuid;
		},

<span id='CKEDITOR-tools-method-override'>		/**
</span>		 * Creates a function override.
		 *
		 *		var obj = {
		 *			myFunction: function( name ) {
		 *				alert( &#39;Name: &#39; + name );
		 *			}
		 *		};
		 *
		 *		obj.myFunction = CKEDITOR.tools.override( obj.myFunction, function( myFunctionOriginal ) {
		 *			return function( name ) {
		 *				alert( &#39;Overriden name: &#39; + name );
		 *				myFunctionOriginal.call( this, name );
		 *			};
		 *		} );
		 *
		 * @param {Function} originalFunction The function to be overridden.
		 * @param {Function} functionBuilder A function that returns the new
		 * function. The original function reference will be passed to this function.
		 * @returns {Function} The new function.
		 */
		override: function( originalFunction, functionBuilder ) {
			var newFn = functionBuilder( originalFunction );
			newFn.prototype = originalFunction.prototype;
			return newFn;
		},

<span id='CKEDITOR-tools-method-setTimeout'>		/**
</span>		 * Executes a function after a specified delay.
		 *
		 *		CKEDITOR.tools.setTimeout( function() {
		 *			alert( &#39;Executed after 2 seconds&#39; );
		 *		}, 2000 );
		 *
		 * @param {Function} func The function to be executed.
		 * @param {Number} [milliseconds=0] The amount of time (in milliseconds) to wait
		 * to fire the function execution.
		 * @param {Object} [scope=window] The object to store the function execution scope
		 * (the `this` object).
		 * @param {Object/Array} [args] A single object, or an array of objects, to
		 * pass as argument to the function.
		 * @param {Object} [ownerWindow=window] The window that will be used to set the
		 * timeout.
		 * @returns {Object} A value that can be used to cancel the function execution.
		 */
		setTimeout: function( func, milliseconds, scope, args, ownerWindow ) {
			if ( !ownerWindow )
				ownerWindow = window;

			if ( !scope )
				scope = ownerWindow;

			return ownerWindow.setTimeout( function() {
				if ( args )
					func.apply( scope, [].concat( args ) );
				else
					func.apply( scope );
			}, milliseconds || 0 );
		},

<span id='CKEDITOR-tools-method-trim'>		/**
</span>		 * Removes spaces from the start and the end of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.trim( &#39;  example &#39; ); // &#39;example&#39;
		 *
		 * @method
		 * @param {String} str The text from which the spaces will be removed.
		 * @returns {String} The modified string without the boundary spaces.
		 */
		trim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /(?:^[ \t\n\r]+)|(?:[ \t\n\r]+$)/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-ltrim'>		/**
</span>		 * Removes spaces from the start (left) of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.ltrim( &#39;  example &#39; ); // &#39;example &#39;
		 *
		 * @method
		 * @param {String} str The text from which the spaces will be removed.
		 * @returns {String} The modified string excluding the removed spaces.
		 */
		ltrim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /^[ \t\n\r]+/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-rtrim'>		/**
</span>		 * Removes spaces from the end (right) of a string. The following
		 * characters are removed: space, tab, line break, line feed.
		 *
		 *		alert( CKEDITOR.tools.ltrim( &#39;  example &#39; ); // &#39;  example&#39;
		 *
		 * @method
		 * @param {String} str The text from which spaces will be removed.
		 * @returns {String} The modified string excluding the removed spaces.
		 */
		rtrim: ( function() {
			// We are not using \s because we don&#39;t want &quot;non-breaking spaces&quot; to be caught.
			var trimRegex = /[ \t\n\r]+$/g;
			return function( str ) {
				return str.replace( trimRegex, &#39;&#39; );
			};
		} )(),

<span id='CKEDITOR-tools-method-indexOf'>		/**
</span>		 * Returns the index of an element in an array.
		 *
		 *		var letters = [ &#39;a&#39;, &#39;b&#39;, 0, &#39;c&#39;, false ];
		 *		alert( CKEDITOR.tools.indexOf( letters, &#39;0&#39; ) );		// -1 because 0 !== &#39;0&#39;
		 *		alert( CKEDITOR.tools.indexOf( letters, false ) );		// 4 because 0 !== false
		 *
		 * @param {Array} array The array to be searched.
		 * @param {Object/Function} value The element to be found. This can be an
		 * evaluation function which receives a single parameter call for
		 * each entry in the array, returning `true` if the entry matches.
		 * @returns {Number} The (zero-based) index of the first entry that matches
		 * the entry, or `-1` if not found.
		 */
		indexOf: function( array, value ) {
			if ( typeof value == &#39;function&#39; ) {
				for ( var i = 0, len = array.length; i &lt; len; i++ ) {
					if ( value( array[ i ] ) )
						return i;
				}
			} else if ( array.indexOf )
				return array.indexOf( value );
			else {
				for ( i = 0, len = array.length; i &lt; len; i++ ) {
					if ( array[ i ] === value )
						return i;
				}
			}
			return -1;
		},

<span id='CKEDITOR-tools-method-search'>		/**
</span>		 * Returns the index of an element in an array.
		 *
		 *		var obj = { prop: true };
		 *		var letters = [ &#39;a&#39;, &#39;b&#39;, 0, obj, false ];
		 *
		 *		alert( CKEDITOR.tools.indexOf( letters, &#39;0&#39; ) ); // null
		 *		alert( CKEDITOR.tools.indexOf( letters, function( value ) {
		 *			// Return true when passed value has property &#39;prop&#39;.
		 *			return value &amp;&amp; &#39;prop&#39; in value;
		 *		} ) );											// obj
		 *
		 * @param {Array} array The array to be searched.
		 * @param {Object/Function} value The element to be found. Can be an
		 * evaluation function which receives a single parameter call for
		 * each entry in the array, returning `true` if the entry matches.
		 * @returns Object The value that was found in an array.
		 */
		search: function( array, value ) {
			var index = CKEDITOR.tools.indexOf( array, value );
			return index &gt;= 0 ? array[ index ] : null;
		},

<span id='CKEDITOR-tools-method-bind'>		/**
</span>		 * Creates a function that will always execute in the context of a
		 * specified object.
		 *
		 *		var obj = { text: &#39;My Object&#39; };
		 *
		 *		function alertText() {
		 *			alert( this.text );
		 *		}
		 *
		 *		var newFunc = CKEDITOR.tools.bind( alertText, obj );
		 *		newFunc(); // Alerts &#39;My Object&#39;.
		 *
		 * @param {Function} func The function to be executed.
		 * @param {Object} obj The object to which the execution context will be bound.
		 * @returns {Function} The function that can be used to execute the
		 * `func` function in the context of `obj`.
		 */
		bind: function( func, obj ) {
			return function() {
				return func.apply( obj, arguments );
			};
		},

<span id='CKEDITOR-tools-method-createClass'>		/**
</span>		 * Class creation based on prototype inheritance which supports of the
		 * following features:
		 *
		 * * Static fields
		 * * Private fields
		 * * Public (prototype) fields
		 * * Chainable base class constructor
		 *
		 * @param {Object} definition The class definition object.
		 * @returns {Function} A class-like JavaScript function.
		 */
		createClass: function( definition ) {
			var $ = definition.$,
				baseClass = definition.base,
				privates = definition.privates || definition._,
				proto = definition.proto,
				statics = definition.statics;

			// Create the constructor, if not present in the definition.
			!$ &amp;&amp; ( $ = function() {
				baseClass &amp;&amp; this.base.apply( this, arguments );
			} );

			if ( privates ) {
				var originalConstructor = $;
				$ = function() {
					// Create (and get) the private namespace.
					var _ = this._ || ( this._ = {} );

					// Make some magic so &quot;this&quot; will refer to the main
					// instance when coding private functions.
					for ( var privateName in privates ) {
						var priv = privates[ privateName ];

						_[ privateName ] = ( typeof priv == &#39;function&#39; ) ? CKEDITOR.tools.bind( priv, this ) : priv;
					}

					originalConstructor.apply( this, arguments );
				};
			}

			if ( baseClass ) {
				$.prototype = this.prototypedCopy( baseClass.prototype );
				$.prototype.constructor = $;
				// Super references.
				$.base = baseClass;
				$.baseProto = baseClass.prototype;
				// Super constructor.
				$.prototype.base = function() {
					this.base = baseClass.prototype.base;
					baseClass.apply( this, arguments );
					this.base = arguments.callee;
				};
			}

			if ( proto )
				this.extend( $.prototype, proto, true );

			if ( statics )
				this.extend( $, statics, true );

			return $;
		},

<span id='CKEDITOR-tools-method-addFunction'>		/**
</span>		 * Creates a function reference that can be called later using
		 * {@link #callFunction}. This approach is especially useful to
		 * make DOM attribute function calls to JavaScript-defined functions.
		 *
		 *		var ref = CKEDITOR.tools.addFunction( function() {
		 *			alert( &#39;Hello!&#39;);
		 *		} );
		 *		CKEDITOR.tools.callFunction( ref ); // &#39;Hello!&#39;
		 *
		 * @param {Function} fn The function to be executed on call.
		 * @param {Object} [scope] The object to have the context on `fn` execution.
		 * @returns {Number} A unique reference to be used in conjuction with
		 * {@link #callFunction}.
		 */
		addFunction: function( fn, scope ) {
			return functions.push( function() {
				return fn.apply( scope || this, arguments );
			} ) - 1;
		},

<span id='CKEDITOR-tools-method-removeFunction'>		/**
</span>		 * Removes the function reference created with {@link #addFunction}.
		 *
		 * @param {Number} ref The function reference created with
		 * {@link #addFunction}.
		 */
		removeFunction: function( ref ) {
			functions[ ref ] = null;
		},

<span id='CKEDITOR-tools-method-callFunction'>		/**
</span>		 * Executes a function based on the reference created with {@link #addFunction}.
		 *
		 *		var ref = CKEDITOR.tools.addFunction( function() {
		 *			alert( &#39;Hello!&#39;);
		 *		} );
		 *		CKEDITOR.tools.callFunction( ref ); // &#39;Hello!&#39;
		 *
		 * @param {Number} ref The function reference created with {@link #addFunction}.
		 * @param {Mixed} params Any number of parameters to be passed to the executed function.
		 * @returns {Mixed} The return value of the function.
		 */
		callFunction: function( ref ) {
			var fn = functions[ ref ];
			return fn &amp;&amp; fn.apply( window, Array.prototype.slice.call( arguments, 1 ) );
		},

<span id='CKEDITOR-tools-method-cssLength'>		/**
</span>		 * Appends the `px` length unit to the size value if it is missing.
		 *
		 *		var cssLength = CKEDITOR.tools.cssLength;
		 *		cssLength( 42 );		// &#39;42px&#39;
		 *		cssLength( &#39;42&#39; );		// &#39;42px&#39;
		 *		cssLength( &#39;42px&#39; );	// &#39;42px&#39;
		 *		cssLength( &#39;42%&#39; );		// &#39;42%&#39;
		 *		cssLength( &#39;bold&#39; );	// &#39;bold&#39;
		 *		cssLength( false );		// &#39;&#39;
		 *		cssLength( NaN );		// &#39;&#39;
		 *
		 * @method
		 * @param {Number/String/Boolean} length
		 */
		cssLength: ( function() {
			var pixelRegex = /^-?\d+\.?\d*px$/,
				lengthTrimmed;

			return function( length ) {
				lengthTrimmed = CKEDITOR.tools.trim( length + &#39;&#39; ) + &#39;px&#39;;

				if ( pixelRegex.test( lengthTrimmed ) )
					return lengthTrimmed;
				else
					return length || &#39;&#39;;
			};
		} )(),

<span id='CKEDITOR-tools-method-convertToPx'>		/**
</span>		 * Converts the specified CSS length value to the calculated pixel length inside this page.
		 *
		 * **Note:** Percentage-based value is left intact.
		 *
		 * @method
		 * @param {String} cssLength CSS length value.
		 */
		convertToPx: ( function() {
			var calculator;

			return function( cssLength ) {
				if ( !calculator ) {
					calculator = CKEDITOR.dom.element.createFromHtml( &#39;&lt;div style=&quot;position:absolute;left:-9999px;&#39; +
						&#39;top:-9999px;margin:0px;padding:0px;border:0px;&quot;&#39; +
						&#39;&gt;&lt;/div&gt;&#39;, CKEDITOR.document );
					CKEDITOR.document.getBody().append( calculator );
				}

				if ( !( /%$/ ).test( cssLength ) ) {
					calculator.setStyle( &#39;width&#39;, cssLength );
					return calculator.$.clientWidth;
				}

				return cssLength;
			};
		} )(),

<span id='CKEDITOR-tools-method-repeat'>		/**
</span>		 * String specified by `str` repeats `times` times.
		 *
		 * @param {String} str
		 * @param {Number} times
		 * @returns {String}
		 */
		repeat: function( str, times ) {
			return new Array( times + 1 ).join( str );
		},

<span id='CKEDITOR-tools-method-tryThese'>		/**
</span>		 * Returns the first successfully executed return value of a function that
		 * does not throw any exception.
		 *
		 * @param {Function...} fn
		 * @returns {Mixed}
		 */
		tryThese: function() {
			var returnValue;
			for ( var i = 0, length = arguments.length; i &lt; length; i++ ) {
				var lambda = arguments[ i ];
				try {
					returnValue = lambda();
					break;
				} catch ( e ) {}
			}
			return returnValue;
		},

<span id='CKEDITOR-tools-method-genKey'>		/**
</span>		 * Generates a combined key from a series of params.
		 *
		 *		var key = CKEDITOR.tools.genKey( &#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39; );
		 *		alert( key ); // &#39;key1-key2-key3&#39;.
		 *
		 * @param {String} subKey One or more strings used as subkeys.
		 * @returns {String}
		 */
		genKey: function() {
			return Array.prototype.slice.call( arguments ).join( &#39;-&#39; );
		},

<span id='CKEDITOR-tools-method-defer'>		/**
</span>		 * Creates a &quot;deferred&quot; function which will not run immediately,
		 * but rather runs as soon as the interpreter’s call stack is empty.
		 * Behaves much like `window.setTimeout` with a delay.
		 *
		 * **Note:** The return value of the original function will be lost.
		 *
		 * @param {Function} fn The callee function.
		 * @returns {Function} The new deferred function.
		 */
		defer: function( fn ) {
			return function() {
				var args = arguments,
					self = this;
				window.setTimeout( function() {
					fn.apply( self, args );
				}, 0 );
			};
		},

<span id='CKEDITOR-tools-method-normalizeCssText'>		/**
</span>		 * Normalizes CSS data in order to avoid differences in the style attribute.
		 *
		 * @param {String} styleText The style data to be normalized.
		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.
		 * @returns {String} The normalized value.
		 */
		normalizeCssText: function( styleText, nativeNormalize ) {
			var props = [],
				name,
				parsedProps = CKEDITOR.tools.parseCssText( styleText, true, nativeNormalize );

			for ( name in parsedProps )
				props.push( name + &#39;:&#39; + parsedProps[ name ] );

			props.sort();

			return props.length ? ( props.join( &#39;;&#39; ) + &#39;;&#39; ) : &#39;&#39;;
		},

<span id='CKEDITOR-tools-method-convertRgbToHex'>		/**
</span>		 * Finds and converts `rgb(x,x,x)` color definition to hexadecimal notation.
		 *
		 * @param {String} styleText The style data (or just a string containing RGB colors) to be converted.
		 * @returns {String} The style data with RGB colors converted to hexadecimal equivalents.
		 */
		convertRgbToHex: function( styleText ) {
			return styleText.replace( /(?:rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\))/gi, function( match, red, green, blue ) {
				var color = [ red, green, blue ];
				// Add padding zeros if the hex value is less than 0x10.
				for ( var i = 0; i &lt; 3; i++ )
					color[ i ] = ( &#39;0&#39; + parseInt( color[ i ], 10 ).toString( 16 ) ).slice( -2 );
				return &#39;#&#39; + color.join( &#39;&#39; );
			} );
		},

<span id='CKEDITOR-tools-method-normalizeHex'>		/**
</span>		 * Normalizes hexadecimal notation so that the color string is always 6 characters long and lowercase.
		 *
		 * @param {String} styleText The style data (or just a string containing hex colors) to be converted.
		 * @returns {String} The style data with hex colors normalized.
		 */
		normalizeHex: function( styleText ) {
			return styleText.replace( /#(([0-9a-f]{3}){1,2})($|;|\s+)/gi, function( match, hexColor, hexColorPart, separator ) {
				var normalizedHexColor = hexColor.toLowerCase();
				if ( normalizedHexColor.length == 3 ) {
					var parts = normalizedHexColor.split( &#39;&#39; );
					normalizedHexColor = [ parts[ 0 ], parts[ 0 ], parts[ 1 ], parts[ 1 ], parts[ 2 ], parts[ 2 ] ].join( &#39;&#39; );
				}
				return &#39;#&#39; + normalizedHexColor + separator;
			} );
		},

<span id='CKEDITOR-tools-method-parseCssText'>		/**
</span>		 * Turns inline style text properties into one hash.
		 *
		 * @param {String} styleText The style data to be parsed.
		 * @param {Boolean} [normalize=false] Normalize properties and values
		 * (e.g. trim spaces, convert to lower case).
		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.
		 * @returns {Object} The object containing parsed properties.
		 */
		parseCssText: function( styleText, normalize, nativeNormalize ) {
			var retval = {};

			if ( nativeNormalize ) {
				// Injects the style in a temporary span object, so the browser parses it,
				// retrieving its final format.
				var temp = new CKEDITOR.dom.element( &#39;span&#39; );
				styleText = temp.setAttribute( &#39;style&#39;, styleText ).getAttribute( &#39;style&#39; ) || &#39;&#39;;
			}

			// Normalize colors.
			if ( styleText ) {
				styleText = CKEDITOR.tools.normalizeHex( CKEDITOR.tools.convertRgbToHex( styleText ) );
			}

			// IE will leave a single semicolon when failed to parse the style text. (#3891)
			if ( !styleText || styleText == &#39;;&#39; )
				return retval;

			styleText.replace( /&amp;quot;/g, &#39;&quot;&#39; ).replace( /\s*([^:;\s]+)\s*:\s*([^;]+)\s*(?=;|$)/g, function( match, name, value ) {
				if ( normalize ) {
					name = name.toLowerCase();
					// Drop extra whitespacing from font-family.
					if ( name == &#39;font-family&#39; )
						value = value.replace( /\s*,\s*/g, &#39;,&#39; );
					value = CKEDITOR.tools.trim( value );
				}

				retval[ name ] = value;
			} );
			return retval;
		},

<span id='CKEDITOR-tools-method-writeCssText'>		/**
</span>		 * Serializes the `style name =&gt; value` hash to a style text.
		 *
		 *		var styleObj = CKEDITOR.tools.parseCssText( &#39;color: red; border: none&#39; );
		 *		console.log( styleObj.color ); // -&gt; &#39;red&#39;
		 *		CKEDITOR.tools.writeCssText( styleObj ); // -&gt; &#39;color:red; border:none&#39;
		 *		CKEDITOR.tools.writeCssText( styleObj, true ); // -&gt; &#39;border:none; color:red&#39;
		 *
		 * @since 4.1
		 * @param {Object} styles The object contaning style properties.
		 * @param {Boolean} [sort] Whether to sort CSS properties.
		 * @returns {String} The serialized style text.
		 */
		writeCssText: function( styles, sort ) {
			var name,
				stylesArr = [];

			for ( name in styles )
				stylesArr.push( name + &#39;:&#39; + styles[ name ] );

			if ( sort )
				stylesArr.sort();

			return stylesArr.join( &#39;; &#39; );
		},

<span id='CKEDITOR-tools-method-objectCompare'>		/**
</span>		 * Compares two objects.
		 *
		 * **Note:** This method performs shallow, non-strict comparison.
		 *
		 * @since 4.1
		 * @param {Object} left
		 * @param {Object} right
		 * @param {Boolean} [onlyLeft] Check only the properties that are present in the `left` object.
		 * @returns {Boolean} Whether objects are identical.
		 */
		objectCompare: function( left, right, onlyLeft ) {
			var name;

			if ( !left &amp;&amp; !right )
				return true;
			if ( !left || !right )
				return false;

			for ( name in left ) {
				if ( left[ name ] != right[ name ] )
					return false;

			}

			if ( !onlyLeft ) {
				for ( name in right ) {
					if ( left[ name ] != right[ name ] )
						return false;
				}
			}

			return true;
		},

<span id='CKEDITOR-tools-method-objectKeys'>		/**
</span>		 * Returns an array of passed object&#39;s keys.
		 *
		 *		console.log( CKEDITOR.tools.objectKeys( { foo: 1, bar: false } );
		 *		// -&gt; [ &#39;foo&#39;, &#39;bar&#39; ]
		 *
		 * @since 4.1
		 * @param {Object} obj
		 * @returns {Array} Object&#39;s keys.
		 */
		objectKeys: function( obj ) {
			var keys = [];
			for ( var i in obj )
				keys.push( i );

			return keys;
		},

<span id='CKEDITOR-tools-method-convertArrayToObject'>		/**
</span>		 * Converts an array to an object by rewriting array items
		 * to object properties.
		 *
		 *		var arr = [ &#39;foo&#39;, &#39;bar&#39;, &#39;foo&#39; ];
		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr ) );
		 *		// -&gt; { foo: true, bar: true }
		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr, 1 ) );
		 *		// -&gt; { foo: 1, bar: 1 }
		 *
		 * @since 4.1
		 * @param {Array} arr The array to be converted to an object.
		 * @param [fillWith=true] Set each property of an object to `fillWith` value.
		 */
		convertArrayToObject: function( arr, fillWith ) {
			var obj = {};

			if ( arguments.length == 1 )
				fillWith = true;

			for ( var i = 0, l = arr.length; i &lt; l; ++i )
				obj[ arr[ i ] ] = fillWith;

			return obj;
		},

<span id='CKEDITOR-tools-method-fixDomain'>		/**
</span>		 * Tries to fix the `document.domain` of the current document to match the
		 * parent window domain, avoiding &quot;Same Origin&quot; policy issues.
		 * This is an Internet Explorer only requirement.
		 *
		 * @since 4.1.2
		 * @returns {Boolean} `true` if the current domain is already good or if
		 * it has been fixed successfully.
		 */
		fixDomain: function() {
			var domain;

			while ( 1 ) {
				try {
					// Try to access the parent document. It throws
					// &quot;access denied&quot; if restricted by the &quot;Same Origin&quot; policy.
					domain = window.parent.document.domain;
					break;
				} catch ( e ) {
					// Calculate the value to set to document.domain.
					domain = domain ?

						// If it is not the first pass, strip one part of the
						// name. E.g.  &quot;test.example.com&quot;  =&gt; &quot;example.com&quot;
						domain.replace( /.+?(?:\.|$)/, &#39;&#39; ) :

						// In the first pass, we&#39;ll handle the
						// &quot;document.domain = document.domain&quot; case.
						document.domain;

					// Stop here if there is no more domain parts available.
					if ( !domain )
						break;

					document.domain = domain;
				}
			}

			return !!domain;
		},

<span id='CKEDITOR-tools-method-eventsBuffer'>		/**
</span>		 * Buffers `input` events (or any `input` calls)
		 * and triggers `output` not more often than once per `minInterval`.
		 *
		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {
		 *			console.log( &#39;foo!&#39; );
		 *		} );
		 *
		 *		buffer.input();
		 *		// &#39;foo!&#39; logged immediately.
		 *		buffer.input();
		 *		// Nothing logged.
		 *		buffer.input();
		 *		// Nothing logged.
		 *		// ... after 200ms a single &#39;foo!&#39; will be logged.
		 *
		 * Can be easily used with events:
		 *
		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {
		 *			console.log( &#39;foo!&#39; );
		 *		} );
		 *
		 *		editor.on( &#39;key&#39;, buffer.input );
		 *		// Note: There is no need to bind buffer as a context.
		 *
		 * @since 4.2.1
		 * @param {Number} minInterval Minimum interval between `output` calls in milliseconds.
		 * @param {Function} output Function that will be executed as `output`.
		 * @param {Object} [scopeObj] The object used to scope the listener call (the `this` object).
		 * @returns {Object}
		 * @returns {Function} return.input Buffer&#39;s input method.
		 * @returns {Function} return.reset Resets buffered events &amp;mdash; `output` will not be executed
		 * until next `input` is triggered.
		 */
		eventsBuffer: function( minInterval, output, scopeObj ) {
			var scheduled,
				lastOutput = 0;

			function triggerOutput() {
				lastOutput = ( new Date() ).getTime();
				scheduled = false;
				if ( scopeObj ) {
					output.call( scopeObj );
				} else {
					output();
				}
			}

			return {
				input: function() {
					if ( scheduled )
						return;

					var diff = ( new Date() ).getTime() - lastOutput;

					// If less than minInterval passed after last check,
					// schedule next for minInterval after previous one.
					if ( diff &lt; minInterval )
						scheduled = setTimeout( triggerOutput, minInterval - diff );
					else
						triggerOutput();
				},

				reset: function() {
					if ( scheduled )
						clearTimeout( scheduled );

					scheduled = lastOutput = 0;
				}
			};
		},

<span id='CKEDITOR-tools-method-enableHtml5Elements'>		/**
</span>		 * Enables HTML5 elements for older browsers (IE8) in the passed document.
		 *
		 * In IE8 this method can also be executed on a document fragment.
		 *
		 * **Note:** This method has to be used in the `&lt;head&gt;` section of the document.
		 *
		 * @since 4.3
		 * @param {Object} doc Native `Document` or `DocumentFragment` in which the elements will be enabled.
		 * @param {Boolean} [withAppend] Whether to append created elements to the `doc`.
		 */
		enableHtml5Elements: function( doc, withAppend ) {
			var els = &#39;abbr,article,aside,audio,bdi,canvas,data,datalist,details,figcaption,figure,footer,header,hgroup,main,mark,meter,nav,output,progress,section,summary,time,video&#39;.split( &#39;,&#39; ),
				i = els.length,
				el;

			while ( i-- ) {
				el = doc.createElement( els[ i ] );
				if ( withAppend )
					doc.appendChild( el );
			}
		},

<span id='CKEDITOR-tools-method-checkIfAnyArrayItemMatches'>		/**
</span>		 * Checks if any of the `arr` items match the provided regular expression.
		 *
		 * @param {Array} arr The array whose items will be checked.
		 * @param {RegExp} regexp The regular expression.
		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.
		 * @since 4.4
		 */
		checkIfAnyArrayItemMatches: function( arr, regexp ) {
			for ( var i = 0, l = arr.length; i &lt; l; ++i ) {
				if ( arr[ i ].match( regexp ) )
					return true;
			}
			return false;
		},

<span id='CKEDITOR-tools-method-checkIfAnyObjectPropertyMatches'>		/**
</span>		 * Checks if any of the `obj` properties match the provided regular expression.
		 *
		 * @param obj The object whose properties will be checked.
		 * @param {RegExp} regexp The regular expression.
		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.
		 * @since 4.4
		 */
		checkIfAnyObjectPropertyMatches: function( obj, regexp ) {
			for ( var i in obj ) {
				if ( i.match( regexp ) )
					return true;
			}
			return false;
		},

<span id='CKEDITOR-tools-property-transparentImageData'>		/**
</span>		 * The data URI of a transparent image. May be used e.g. in HTML as an image source or in CSS in `url()`.
		 *
		 * @since 4.4
		 * @readonly
		 */
		transparentImageData: &#39;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&#39;,


<span id='CKEDITOR-tools-method-getCookie'>		/**
</span>		 * Returns the value of the cookie with a given name or `null` if the cookie is not found.
		 *
		 * @since 4.5.6
		 * @param {String} name
		 * @returns {String}
		 */
		getCookie: function( name ) {
			name = name.toLowerCase();
			var parts = document.cookie.split( &#39;;&#39; );
			var pair, key;

			for ( var i = 0; i &lt; parts.length; i++ ) {
				pair = parts[ i ].split( &#39;=&#39; );
				key = decodeURIComponent( CKEDITOR.tools.trim( pair[ 0 ] ).toLowerCase() );

				if ( key === name ) {
					return decodeURIComponent( pair.length &gt; 1 ? pair[ 1 ] : &#39;&#39; );
				}
			}

			return null;
		},

<span id='CKEDITOR-tools-method-setCookie'>		/**
</span>		 * Sets the value of the cookie with a given name.
		 *
		 * @since 4.5.6
		 * @param {String} name
		 * @param {String} value
		 */
		setCookie: function( name, value ) {
			document.cookie = encodeURIComponent( name ) + &#39;=&#39; + encodeURIComponent( value ) + &#39;;path=/&#39;;
		},

<span id='CKEDITOR-tools-method-getCsrfToken'>		/**
</span>		 * Returns the CSRF token value. The value is a hash stored in `document.cookie`
		 * under the `ckCsrfToken` key. The CSRF token can be used to secure the communication
		 * between the web browser and the server, i.e. for the file upload feature in the editor.
		 *
		 * @since 4.5.6
		 * @returns {String}
		 */
		getCsrfToken: function() {
			var token = CKEDITOR.tools.getCookie( TOKEN_COOKIE_NAME );

			if ( !token || token.length != TOKEN_LENGTH ) {
				token = generateToken( TOKEN_LENGTH );
				CKEDITOR.tools.setCookie( TOKEN_COOKIE_NAME, token );
			}

			return token;
		},

<span id='CKEDITOR-tools-method-escapeCss'>		/**
</span>		 * Returns an escaped CSS selector. `CSS.escape()` is used if defined, leading digit is escaped otherwise.
		 *
		 * @since 4.5.10
		 * @param {String} selector A CSS selector to escape.
		 * @returns {String} An escaped selector.
		 */
		escapeCss: function( selector ) {
			// Invalid input.
			if ( !selector ) {
				return &#39;&#39;;
			}

			// CSS.escape() can be used.
			if ( window.CSS &amp;&amp; CSS.escape ) {
				return CSS.escape( selector );
			}

			// Simple leading digit escape.
			if ( !isNaN( parseInt( selector.charAt( 0 ), 10 ) ) ) {
				return &#39;\\3&#39; + selector.charAt( 0 ) + &#39; &#39; + selector.substring( 1, selector.length );
			}

			return selector;
		}
	};

	// Generates a CSRF token with a given length.
	//
	// @since 4.5.6
	// @param {Number} length
	// @returns {string}
	function generateToken( length ) {
		var randValues = [];
		var result = &#39;&#39;;

		if ( window.crypto &amp;&amp; window.crypto.getRandomValues ) {
			randValues = new Uint8Array( length );
			window.crypto.getRandomValues( randValues );
		} else {
			for ( var i = 0; i &lt; length; i++ ) {
				randValues.push( Math.floor( Math.random() * 256 ) );
			}
		}

		for ( var j = 0; j &lt; randValues.length; j++ ) {
			var character = tokenCharset.charAt( randValues[ j ] % tokenCharset.length );
			result += Math.random() &gt; 0.5 ? character.toUpperCase() : character;
		}

		return result;
	}
} )();

// PACKAGER_RENAME( CKEDITOR.tools )
</pre>
</body>
</html>
